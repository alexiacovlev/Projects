<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ITHit.WebDAV.Server</name>
    </assembly>
    <members>
        <member name="T:ITHit.WebDAV.Server.Acl.AceType">
            <summary>
            Type of <see cref="T:ITHit.WebDAV.Server.Acl.ReadAce"/> or <see cref="T:ITHit.WebDAV.Server.Acl.WriteAce"/> record.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.AceType.Grant">
            <summary>
            Grants permissions.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.AceType.Deny">
            <summary>
            Denies permissions.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.AclRestriction">
            <summary>
            Defines the types of ACLs supported by the server, to avoid clients needlessly getting
            errors.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.GrantOnly">
            <summary>
            Indicates that ACEs with <see cref="P:ITHit.WebDAV.Server.Acl.WriteAce.DenyPrivileges"/> are not allowed.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.NoInvert">
            <summary>
            Indicates that ACEs with <see cref="P:ITHit.WebDAV.Server.Acl.WriteAce.GrantPrivileges"/> == false are not supported.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.AclRestriction.RequiredPrincipals">
            <summary>
            Indicates which principals are required to be present in ACL.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IAccessControl">
            <summary>
            Represents an item that supports WebDAV ACL. Enables <b>access-control</b> feature support discovery.
            </summary>
            <remarks>
            <para>This is a marker interface, it does not provide any propertes or methods.</para>
            <para>
            Items that implement this interface report ACL support in OPTIONS requests. 
            If this intervace is found on an item, the <b>DAV</b> header will include <b>access-control</b> token.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IAclHierarchyItem">
            <summary>
            Interface to be implemented by hierarchy items that support setting permissions (ACL). 
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipal">
            <summary>
            Assists in finding currently loged-in user. Provides <b>current-user-principal</b> feature support.
            Required by iOS and OS X CalDAV and CardDAV clients on folders pointed to by '.well-known' requests (context path folder).
            </summary>
            <remarks>
            <para>
            This interface provides <see cref="M:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipal.GetCurrentUserPrincipal"/>) method that is called by the Engine 
            when client is discovering currently logged-in user.
            </para>
            <para>
            This interface is optional on hierarchy items. However, to support iOS and OS X CalDAV and CardDAV 
            clients this interface must be implemented on item redirected to by /.well-known/caldav and 
            /.well-known/carddav responses. iOS and OS X CalDAV and CardDAV clients request 
            <b>current-user-principal</b> and <b>principal-URL</b> properties on these items and would not connect to server if 
            no proper responce is provided.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.ICurrentUserPrincipal.GetCurrentUserPrincipal">
            <summary>
            Retrieves currently logged in principal.
            </summary>
            <remarks>The Engine will request <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Path"/> on the returned item.</remarks>
            <returns>Currently logged in principal.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ICurrentUserPrincipal.GetCurrentUserPrincipal&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.IHierarchyItem">
            <summary>
            Represents one item (file, folder) in the WebDAV repository.
            </summary>
            <remarks>
            Defines the properties and methods common to all WebDAV folders and files.
            <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Created"/> and <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.ModifiedOn"/> properties must return Universal Coordinated Time (UTC).
            <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.GetProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/> are called when WebDAV client is reading, adding,
            updating or deleting properties.  This interface also provides methods for managing hierarchy: moving, copying
            and deleting WebDAV items.  See <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IItemCollection,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IItemCollection,System.String,ITHit.WebDAV.Server.MultistatusException)"/> and <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.Delete(ITHit.WebDAV.Server.MultistatusException)"/> methods.
            Your file items must implement <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/> interface, folder items - <see cref="T:ITHit.WebDAV.Server.Class1.IFolder"/> interface.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IItemCollection,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Creates a copy of this item with a new name in the destination folder.
            </summary>
            <param name="destFolder">Destination folder.</param>
            <param name="destName">Name of the destination item.</param>
            <param name="deep">Indicates whether to copy entire subtree.</param>
            <param name="multistatus">If some items fail to copy but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus"/> using 
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)"/>.
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">Destination item was locked and client did not provide
            lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree and
            whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> if destination folder doesn't exist.
            </exception>
            <remarks>
            <para>
            If error occurred while copying file located in a subtree, the server 
            should try to continue copy operation and copy all other items. In this case 
            you must add that error <paramref name="multistatus"/> container.
            </para>
            <para>
            A CopyTo method invocation must not copy any locks active on the source item.
            However, if this method copies the item into a folder that has a deep lock,
            then the destination item must be added to the lock.
            </para>
            </remarks>
            <example>
            Example of <c>CopyTo</c> implementation for WebDAV Class 2 server:
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.CopyTo&quot;]/example/*"/>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IItemCollection,System.String,ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Moves this item to the destination folder under a new name.
            </summary>
            <param name="destFolder">Destination folder.</param>
            <param name="destName">Name of the destination item.</param>
            <param name="multistatus">If some items fail to copy but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus"/> using 
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)"/>.
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The source or the destination item was locked and client did not provide
            lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree and
            whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> if destination folder doesn't exist.
            </exception>
            <remarks>
            <papa>
            If the item is locked the server must not move any locks with the item. However, items must be added to an
            existing lock at the destination.
            </papa>
            </remarks>
            <example>
            Example of <c>MoveTo</c> implementation for WebDAV Class 2 server:
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.MoveTo&quot;]/example/*"/>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.Delete(ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Deletes this item.
            </summary>
            <param name="multistatus">If some items fail to delete but operation in whole shall be continued, add
            information about the error into <paramref name="multistatus"/> using
            <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)"/>.
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item or its parent was locked and client did not provide lock
            token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of item in the subtree
            and whole operation shall be aborted.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.
            Possible status value is <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> if destination folder doesn't exist.
            </exception>
            <example>
            Example of <c>Delete</c> implementation for WebDAV Class 2 server:
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.Delete&quot;]/example/*"/>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.GetProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)">
            <summary>
            Gets values of all properties or selected properties for this item.
            </summary>
            <param name="props">
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> with property names which values are requested by WebDAV client. 
            If a property does not exist for this hierarchy item then the property value shall not be returned.
            </param>
            <param name="allprop">
            If it is <c>true</c> it means that besides properties listed in <paramref name="props"/> you need to 
            return all properties you think may be useful to client.
            </param>
            <returns>
            Enumerable with property values.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.GetProperties&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.GetPropertyNames">
            <summary>
            Gets names of all properties for this item.
            </summary>
            <returns>
            Enumerable with available property names.
            </returns>
            <remarks>
            <para>Most WebDAV clients never request list of property names, so your implementation can just return
            empty enumerable.</para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.GetPropertyNames&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Adds, modifies and removes properties for this item.
            </summary>
            <param name="setProps">List of properties to be set.</param>
            <param name="delProps">List of property names to be removed. Properties that don't exist shall be skipped.</param>
            <param name="multistatus">The standard requires this operation to be transactional.
            If some properties fail to update but there is no possibility to rollback the transaction
            in <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/>, add
            information about the error into <paramref name="multistatus"/> 
            using <see cref="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.DavException)"/>.
            In this case engine will report correct statuses for all properties at least
            (although this is against standard).
            </param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked and client
            did not provide lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">
            The exception shall contain statuses for all properties that
            failed to update.
            Typical property error statuses:
            <list type="bullet">
            <item>
            <description>
            <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> - the client has provided a value
            whose semantics are not appropriate for the property, this includes
            trying to set read-only properties.
            </description>
            </item>
            <item>
            <description>
            <see cref="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY"/> - indicates this action would
            have succeeded if it were not for the conflict with
            updating/removing some other property.
            </description>
            </item>
            </list>
            </exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            In your <c>UpdateProperties</c> implementation you will create,
            modify and delete item properties.
            Single property update request may invoke following methods of single item which update properties:
            <list type="bullet">
                <item><see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetOwner(ITHit.WebDAV.Server.Acl.IPrincipal)"/></item>
                <item><see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetGroup(ITHit.WebDAV.Server.Acl.IPrincipal)"/></item>
                <item><see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.SetAutoVersion(ITHit.WebDAV.Server.DeltaV.AutoVersion)"/></item>
                <item><see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.SetComment(System.String)"/></item>
                <item><see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.SetCreatorDisplayName(System.String)"/></item>
                <item><see cref="M:ITHit.WebDAV.Server.Acl.IPrincipal.SetGroupMembers(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.IPrincipal})"/></item>
                <item><see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/></item>
            </list>
            Engine will update properties (call these methods) one by one unless exception is thrown.
            If an exception is thrown during a property update engine will report all remaining properties
            as failed with status <see cref="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY"/>
            </para>
            <para>
            The standard requires that request which updates properties is atomic (PROPPATCH).
            If your storage supports transactions then atomicity requirement can be implemented
            by committing or rollbacking the transaction in <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/>.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.UpdateProperties&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Name">
            <summary>
            Gets the name of the item in repository.
            </summary>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.Name&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Created">
            <summary>
            Gets the creation date of the item in repository expressed as the coordinated universal time (UTC).
            </summary>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.Created&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Modified">
            <summary>
            Gets the last modification date of the item in repository expressed as the coordinated universal time (UTC).
            </summary>
            <remarks>
            Value of this property must change only when content of the item changes. It must not change when item is locked or
            unlocked or properties modified. In particular Mac OS relies on such behavior.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.Modified&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IHierarchyItem.Path">
            <summary>
            Unique item path in the repository relative to storage root.
            </summary>
            <remarks>
            <para>
            The URL returned by this property is relative to storage root.
            If your server root is located at http://example.webdavsystem.com:8080/myserver/ and the item URL is
            http://example.webdavsystem.com:8080/myserver/myfolder/myitem.doc this property implementation must
            return myfolder/myitem.doc. To calculate the entire item URL the engine will
            call <see cref="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ApplicationPath"/> property and attach it to url returned by
            <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Path"/> property.
            </para>
            <para>
            Every part of the path (between '/' characters) shall be encoded,
            for example using <see cref="T:ITHit.WebDAV.Server.EncodeUtil"/>.
            </para>
            <para>Examples:
            <list type="bullet">
            <item><description>File: myfolder/my%20doc.docx</description></item>
            <item><description>Folder: myfolder/folder/</description></item>
            <item><description>History item: myfolder/mydoc.docx?history</description></item>
            <item><description>Version: myfolder/mydoc.docx?version=5</description></item>
            </list>
            </para>
            </remarks>
            <value><c>String</c> representing relative item path in the repository.</value>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IHierarchyItem.Path&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetOwner(ITHit.WebDAV.Server.Acl.IPrincipal)">
            <summary>
            Retrieves a particular principal as being the "owner" of the item. Since the owner of a
            resource often has special access control capabilities (e.g., the owner frequently has permanent
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/> privilege), clients might display the resource owner in their
            user interface.
            </summary>
            <param name="value">Identifies whether to search by owner or group.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.SetOwner&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetOwner">
            <summary>
            Retrieves a particular principal as being the "owner" of the item. Since the owner of a
            resource often has special access control capabilities (e.g., the owner frequently has permanent
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/> privilege), clients might display the resource owner in their user
            interface.
            </summary>
            <returns>
            Item that represents owner of this item and implements <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipal"/>.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>Can be null.</remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetOwner&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetGroup(ITHit.WebDAV.Server.Acl.IPrincipal)">
            <summary>
            Retrieves a particular principal as being the "group" of the item. This property is commonly
            found on repositories that implement the Unix privileges model.
            </summary>
            <param name="value">Identifies whether to search by owner or group.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.SetGroup&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetGroup">
            <summary>
            Retrieves a particular principal as being the "group" of the item. This property is commonly
            found on repositories that implement the Unix privileges model.
            </summary>
            <returns>
            Group principal that implements <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipal"/>.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>
            Can return null if group is not assigned.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetGroup&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetSupportedPrivilegeSet">
            <summary>
            Retrieves the privileges defined for the resource.
            </summary>
            <returns>
            List of <see cref="T:ITHit.WebDAV.Server.Acl.SupportedPrivilege"/>.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetSupportedPrivilegeSet&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetCurrentUserPrivilegeSet">
            <summary>
            Retrieves the exact set of privileges (as computed by
            the server) granted to the currently authenticated HTTP user. Aggregate privileges and their contained
            privileges are listed. A user-agent can use the value of this property to adjust its user interface to
            make actions inaccessible (e.g., by graying out a menu item or button) for which the current principal
            does not have permission. This property is also useful for determining what operations the current
            principal can perform, without having to actually execute an operation.
            </summary>
            <returns>
            List of current user privileges.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetCurrentUserPrivilegeSet&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Specifies the list of access control entries (ACEs), which define what principals
            are to get what privileges for this resource.
            </summary>
            <param name="propertyNames">List of properties that might be retrieved from those <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipal"/>
            returned.</param>
            <returns>
            A set of privileges.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <remarks>
            <paramref name="propertyNames"/>Is for optimization purposes and you may ignore it.
            For "principal-pop-set" report engine will call this method, retrieve all principals from result
            and extract properties specified in <paramref name="propertyNames"/> from it. In this case prefetching
            these properties may improve performance.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetAcl&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})">
            <summary>
            Sets list of access control entries (ACEs), which define what principals
            are to get what privileges for this resource.
            </summary>
            <param name="aces">Identifies whether to search by owner or group.</param>
            <remarks>
            Two common operations are to add or remove an ACE from an existing access
            control list. To accomplish this, a client uses the PROPFIND method to retrieve the value of the DAV:acl
            property, then parses the returned access control list to remove all inherited and protected ACEs (these
            ACEs are tagged with the DAV:inherited and DAV:protected XML elements). In the remaining set of
            non-inherited, non-protected ACEs, the client can add or remove one or more ACEs before submitting the
            final ACE set in the request body of the ACL method.
            It is possible that the ACEs visible to the current user in the DAV:acl property may only be a portion of
            the complete set of ACEs on that resource. If this is the case, an ACL request only modifies the set of
            ACEs visible to the current user, and does not affect any non-visible ACE.
            </remarks>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.
            It is possible for status code to be <see cref="F:ITHit.WebDAV.Server.DavStatus.CONFLICT"/> and error description one of values
            in <see cref="T:ITHit.WebDAV.Server.Acl.SetAclErrorDetails"/> class.
            </exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.SetAcl&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetAclRestrictions">
            <summary>
            Defines the types of ACLs supported by this server, to avoid clients needlessly getting
            errors. When a client tries to set an ACL via the ACL method, the server may reject the attempt to set
            the ACL as specified.
            </summary>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Acl.AclRestriction"/>.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetAclRestrictions&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetInheritedAclSet">
            <summary>
            Contains a set of items that also control the access to this item.
            To have a privilege on an item, not only must the ACL on that item (specified in the <see cref="N:ITHit.WebDAV.Server.Acl"/>
            property of that item) grant the privilege, but so must the ACL of each items identified in the
            <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetInheritedAclSet"/> property of that item. Effectively, the privileges granted by the current
            ACL are ANDed with the privileges granted by each inherited ACL.
            </summary>
            <returns>
            List of <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> items.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetInheritedAclSet&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetPrincipalCollectionSet">
            <summary>
            Retrieves a set of root collections that contain the
            principals that are available on the server that implements this resource. It can be used to retrieve the 
            <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Name"/> properties
            of all principals on that server, thereby yielding human-readable
            names for each principal that could be displayed in a user interface.
            </summary>
            <returns>
            List of <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalFolder"/> items.
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetPrincipalCollectionSet&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.ResolveWellKnownPrincipal(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)">
            <summary>
            Returns predefined principal.
            </summary>
            <param name="wellKnownPrincipal">One of <see cref="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal"/> values.</param>
            <returns>Well known principal or <c>null</c> if it is not supported.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.ResolveWellKnownPrincipal&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetItemsByProperty(ITHit.WebDAV.Server.Acl.MatchBy,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Find all resources in the subtree which have either Group or Owner (defined by <paramref name="matchBy"/>
            parameter) which identifies current user or group current user belongs to.
            For example, this report can return all of the resources in a collection
            hierarchy that are owned by the current user.
            </summary>
            <param name="matchBy">Identifies whether to search by owner or group.</param>
            <param name="props">Properties requested for found items.</param>
            <returns>List of matching resources, each implementing <see cref="T:ITHit.WebDAV.Server.Acl.IAclHierarchyItem"/>.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IAclHierarchyItem.GetItemsByProperty&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IPrincipal">
            <summary>
            Represents a principal - a distinct human or computational actor that initiates access to
            items in WebDAV repository.
            </summary>
            <remarks>
            <para>
            Users and groups are represented as principals in many implementations;
            other types of principals are also possible. 
            A principal item may be a group, where a group is a principal that represents a set of other principals,
            called the members of the group. If a person or computational agent matches a principal resource that is a
            member of a group, they also match the group. Membership in a group is recursive, so if a principal is a
            member of group GRPA, and GRPA is a member of group GRPB, then the principal is also a member of
            GRPB.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipal.SetGroupMembers(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.IPrincipal})">
            <summary>
            Replaces members of the group to be those specified in <paramref name="members"/> parameter.
            </summary>
            <param name="members">New member(user or groups) list.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.SetGroupMembers&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipal.GetGroupMembers">
            <summary>
            Retrieves principals that are direct members of this group. 
            </summary>
            <remarks>
            Since a group
            may be a member of another group, a group may also have indirect members (i.e., the members of its direct
            members). 
            </remarks>
            <returns>Members of the group identified by this principal.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The item is locked and no or invalid lock token was provided.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.GetGroupMembers&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipal.IsWellKnownPrincipal(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)">
            <summary>
            Determines whether the principal is well known, the one that is defined by
            <see cref="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal"/> enumeration.
            </summary>
            <param name="wellknownPrincipal">Type of wellknown principal to check this one against.</param>
            <returns>Whether the principal is <paramref name="wellknownPrincipal"/>.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.IsWellKnownPrincipal&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipal.GetGroupMembership">
            <summary>
            Identifies the groups in which the principal is directly a member. 
            </summary>
            <remarks>
            Note that a server may
            allow a group to be a member of another group, in which case the <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipal.GetGroupMembership"/>
            of those other groups would need to be queried in order to determine the groups in which the principal
            is indirectly a member.
            </remarks>
            <returns>Returns group this principal belongs to.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipal.GetGroupMembership&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.IPrincipalFolder">
            <summary>
            Represents a folder that contains principals.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.IItemCollection">
            <summary>
            Base interface for folders.
            </summary>
            <remarks>
            <para>Base interface for all kinds of folders (<see cref="T:ITHit.WebDAV.Server.Class1.IFolder"/>, <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalFolder"/> etc.).</para>
            <para>In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> interface this interface also provides <see cref="M:ITHit.WebDAV.Server.IItemCollection.GetChildren(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/> method to list children of this folder.</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.IItemCollection.GetChildren(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets direct children of this folder.
            </summary>
            <param name="propNames">List of properties requested by the client.</param>
            <returns><see cref="T:System.Collections.Generic.IEnumerable`1"/> with <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> items. Each item is a file or folder item.</returns>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IItemCollection.GetChildren&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.CreateFolder(System.String)">
            <summary>
            Creates principal folder with given name.
            </summary>
            <param name="name">Principal folder name.</param>
            <returns>Newly created folder.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.CreateFolder&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.CreatePrincipal(System.String)">
            <summary>
            Creates principal with given name.
            </summary>
            <param name="name">Principal name</param>
            <returns>Newly created principal.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            The principal created can be either group or user. One of the way to distinguish is
            to create separate folders for users and for groups, so in one folder only users
            can be created, and in another one only groups.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.CreatePrincipal&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.FindPrincipalsByPropertyValues(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Performs a search for all principals in this folder whose properties contain
            character data that matches the search criteria specified.
            One expected use of this method is to
            discover principals by searching for them by name. This is
            done by searching over <see cref="F:ITHit.WebDAV.Server.PropertyName.DISPLAYNAME"/> (<see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Name"/>),
            which is defined on all principals.
            </summary>
            <param name="propValuesToSearch">Properties with values to search for.</param>
            <param name="propsToReturn">Properties to return for each item found.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">Not enough permissions.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In case of other errors.
            If there are too many items server may return this exception with status
            <see cref="F:ITHit.WebDAV.Server.DavStatus.PRECONDITION_FAILED"/> and description 
            <see cref="F:ITHit.WebDAV.Server.ErrorDetails.NUMBER_OF_MATCHES_WITHIN_LIMITS"/>
            </exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.FindPrincipalsByPropertyValues&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.GetPrincipalSearcheableProperties">
            <summary>
            Identifies those properties that may be searched using the
            <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.FindPrincipalsByPropertyValues(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/> method (DAV:principal-property-search REPORT defined
            in Section 9.4).
            A client could use the results of this method
            to present a query interface to the user for retrieving principals.
            </summary>
            <returns>Searcheable properties.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.GetPrincipalSearcheableProperties&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.GetMatchingPrincipals(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Is used to find all groups residing in the subtree of current item which contain currently authenticated
            user. The user itself shall also be included if it is located in the subtree of this item.
            </summary>
            <param name="props">Properties to return with every item found.</param>
            <returns>Groups which contain currently authenticated user.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IPrincipalFolder.GetMatchingPrincipals&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.WellKnownPrincipal">
            <summary>
            Lists predefined principals having special meaning in WebDav.
            Urls of these principals will be retrieved using <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.ResolveWellKnownPrincipal(ITHit.WebDAV.Server.Acl.WellKnownPrincipal)"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.All">
            <summary>
            Matches all principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Authenticated">
            <summary>
            Matches all authenticated principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Unauthenticated">
            <summary>
            Matches all unauthenticated principals.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Self">
            <summary>
            Matches currently logged in principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Owner">
            <summary>
            Matches principal that is owner of hierarchy item.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Group">
            <summary>
            Matches principal that is group of hierarchy item.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.Privilege">
            <summary>
            Specifies a privilege that can be given to a principal on an item.
            </summary>
            <remarks>
            Ability to perform a method on an item is controlled by one or more privileges.
            A principal with no privileges to a resource will be denied any access to that resource, unless the principal
            matches an ACE constructed using the <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.All"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Authenticated"/>, or <see cref="F:ITHit.WebDAV.Server.Acl.WellKnownPrincipal.Unauthenticated"/>
            pseudo-principals.
            Privileges may be containers of other privileges, in which case they are termed "aggregate privileges". If a
            principal is granted or denied an aggregate privilege, it is semantically equivalent to granting or denying each
            of the aggregated privileges individually. For example, an implementation may define add-member and
            remove-member privileges that control the ability to add and remove a member of a group. Since these
            privileges control the ability to update the state of a group, these privileges would be aggregated by the
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/> privilege on a group, and granting the <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/> privilege
            on a group would also grant the add-member and remove-member privileges.
            Privileges may be declared to be "abstract" for a given resource, in which case they cannot be set in an ACE on
            that resource. Aggregate and non-aggregate privileges are both capable of being abstract. Abstract privileges
            are useful for modeling privileges that otherwise would not be exposed via the protocol. Abstract privileges
            also provide server implementations with flexibility in implementing the privileges.  For example, if a server
            is incapable of separating the read item capability from the read ACL  capability, it can still model the
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> privileges defined in this specification by
            declaring them abstract, and containing them within a non-abstract aggregate privilege (say, read-all) that
            holds <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>. In this way, it is possible to set
            the aggregate privilege, read-all, thus coupling the setting of <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> and
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>, but it is not possible to set <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, or
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> individually. Since aggregate privileges can be abstract, it is also possible
            to use abstract privileges to group or organize non-abstract privileges. Privilege containment loops are not
            allowed; therefore, a privilege MUST NOT contain itself. For example, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> cannot
            contain <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>. The set of privileges that apply to a particular item may vary with the 
            type of item (folder, resource), as well as between different server implementations. To promote 
            interoperability, however, a set of well-known privileges (e.g., <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/>, <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl"/>,
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadCurrentUserPrivilegeSet"/>, and <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.All"/>) is defined, which can at least
            be used to classify the other privileges defined on a particular resource. 
            Server implementations MAY define new privileges beyond those defined in <see cref="T:ITHit.WebDAV.Server.Acl.Privilege"/>. Privileges
            defined by individual implementations MUST NOT use the DAV: namespace, and instead should use a
            namespace that they control, such as an http scheme URL.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Namespace">
            <summary>
            Namespace of privilege.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Name">
            <summary>
            Privilege name.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Read">
            <summary>
            Controls methods that return information about the state of the resource, including the
            resource's properties. Affected methods include downloading content and retrieving information about item.
            </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to donwloading content and retrieving
            information must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/> - if an ACL grants
            access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Read"/>, the client may expect that no other privilege needs to be granted to have
            access to downloading content and retrieving information.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Write">
            <summary>
            Controls methods that lock an item or modify the content, properties, or 
            membership of a collection.
            </summary>
            <remarks>
            State modification is  also controlled via locking, so effective write access requires that both write
            privileges and write locking requirements are satisfied. Any implementation-defined privilege that also
            controls access to methods modifying content, properties or folder membership must be aggregated under
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, e.g., if an ACL grants access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Write"/>, the client may expect that no
            other privilege needs to be granted to modify item's state.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties">
            <summary>
            Controls methods that modify properties of the resource.
            Such as <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/>.
            </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to methods modifying
            properties must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties"/> - e.g., if an ACL grants access to
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteProperties"/>, the client can safely expect that no other privilege needs to be granted
            to have access to modifying properties.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent">
            <summary>
            Controls methods that modify the content of an existing resource, such as <see cref="M:ITHit.WebDAV.Server.IContent.Write(System.IO.Stream,System.String,System.Int64,System.Int64)"/>.
             </summary>
            <remarks>
            Any implementation-defined privilege that also controls access to content must be aggregated under
            <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent"/> - e.g., if an ACL grants access to <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.WriteContent"/>,
            the client can safely expect that no other privilege needs to be granted to have access to modifying content.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock">
            <summary>
            Controls the use of the <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/> method by a principal other than the lock owner
            (the principal that created a lock can always perform an <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/>).
            </summary>
            <remarks>
            While the set of users who may lock a
            resource is most commonly the same set of users who may modify a resource, servers may allow various kinds
            of administrators to unlock resources locked by others. Any privilege controlling access by non-lock owners
            to <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/> must be aggregated under <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/>.
            A lock owner can always remove a lock by issuing an <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/> with the correct lock token
            and authentication credentials. That is, even if a principal does not have <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege,
            they can still remove locks they own. Principals other than the lock owner can remove a lock only if they
            have <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege and they issue an <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/> with the correct lock
            token. Lock timeout is not affected by the <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.Unlock"/> privilege.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl">
            <summary>
            Controls the use of <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.ReadCurrentUserPrivilegeSet">
            <summary>
            Controls the use of <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetCurrentUserPrivilegeSet"/>.
            </summary>
            <remarks>
            Clients are intended to use this property to visually indicate in their UI items that are dependent on the
            permissions of a resource, for example, by graying out resources that are not writable.
            This privilege is separate from <see cref="F:ITHit.WebDAV.Server.Acl.Privilege.ReadAcl"/> because there is a need to allow most users access
            to the privileges permitted the current user (due to its use in creating the UI), while the full ACL
            contains information that may not be appropriate for the current authenticated user. As a result, the
            set of users who can view the full ACL is expected to be much smaller than those who can read the current
            user privilege set, and hence distinct
            privileges are needed for each.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.WriteAcl">
            <summary>
            Controls user of <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})"/> method.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Bind">
            <summary>
            Allows creating child items in a collection.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.Unbind">
            <summary>
            Allows removing child items from collection (for example using <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.Delete(ITHit.WebDAV.Server.MultistatusException)"/>
            or <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IItemCollection,System.String,ITHit.WebDAV.Server.MultistatusException)"/>).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.Privilege.All">
            <summary>
            Is an aggregate privilege that contains the entire set of privileges that can be applied to the item.
            </summary>        
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the Privilege class.
            </summary>
            <param name="namespace">Privilege namespace.</param>
            <param name="name">Privilege name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.op_Equality(ITHit.WebDAV.Server.Acl.Privilege,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c>if operands are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.op_Inequality(ITHit.WebDAV.Server.Acl.Privilege,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Unequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c>if operands are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.Equals(ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.Privilege.ToString">
            <summary>
            Returns string representation of a privilege.
            </summary>
            <returns>String representation of the privilege.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.PropertyDescription">
            <summary>
            Used in result of <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipalFolder.GetPrincipalSearcheableProperties"/>.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Name">
            <summary>
            Property name.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Description">
            <summary>
            Property description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.PropertyDescription.Lang">
            <summary>
            Property description language.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.ReadAce">
            <summary>
            Specifies the set of privileges to be either granted or denied to a single principal.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.Principal">
            <summary>
            Principal to which privileges are granted and denied by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.IsProtected">
            <summary>
            Indicates that this ACE is protected and an attempt to remove it will fail.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.InheritedFrom">
            <summary>
            If not null indicates a resource from which this Ace is inherited.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.GrantPrivileges">
            <summary>
            Privileges granted by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.DenyPrivileges">
            <summary>
            Privileges denied by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.ReadAce.IsInvert">
            <summary>
            If this property is true then this ACE grants/denies privileges to all
            principals NOT matching the one in <see cref="P:ITHit.WebDAV.Server.Acl.ReadAce.Principal"/> property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.SetAclErrorDetails">
            <summary>
            Error codes that can be returned as part of <see cref="T:ITHit.WebDAV.Server.DavException"/> during call
            to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})"/> method.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with each other. This is
            a catchall error code indicating that an implementation-specific ACL restriction has been violated.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoProtectedAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with the
            protected ACEs on the resource. For example, if the resource has a protected ACE granting DAV:write to a
            given principal, then it would not be consistent if the ACL request submitted an ACE denying DAV:write to
            the same principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoInheritedAceConflict">
            <summary>
            The ACEs submitted in the ACL request MUST NOT conflict with the
            inherited ACEs on the resource. For example, if the resource inherits an ACE from its parent collection
            granting DAV:write to a given principal, then it would not be consistent if the ACL request submitted an ACE
            denying DAV:write to the same principal. Note that reporting of this error will be implementation-dependent.
            Implementations MUST either report this error or allow the ACE to be set, and then let normal ACE evaluation
            rules determine whether the new ACE has any impact on the privileges available to a specific principal.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.LimitedNumberOfAces">
            <summary>
            (DAV:limited-number-of-aces): The number of ACEs submitted in the ACL request MUST NOT exceed the
            number of ACEs allowed on that resource. However, ACL-compliant servers MUST support at least one ACE
            granting privileges to a single principal, and one ACE granting privileges to a group.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.DenyBeforeGrant">
            <summary>
            All non-inherited deny ACEs MUST precede all non-inherited grant ACEs.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.GrantOnly">
            <summary>
            The ACEs submitted in the ACL request MUST NOT include a deny ACE. This
            precondition applies only when the ACL restrictions of the resource include the DAV:grant-only constraint
            (defined in Section 5.6.1).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoInvert">
            <summary>
            The ACL request MUST NOT include a DAV:invert element. This precondition applies only
            when the ACL semantics of the resource includes the DAV:no-invert constraint (defined in Section 5.6.2).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NoAbstract">
            <summary>
            The ACL request MUST NOT attempt to grant or deny an abstract privilege (see
            Section 5.3).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.NotSupporterPrivilege">
            <summary>
            The ACEs submitted in the ACL request MUST be supported by the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.MissingRequiredPrincipal">
            <summary>
            The result of the ACL request MUST have at least one ACE for each
            principal identified in a DAV:required-principal XML element in the ACL semantics of that resource (see
            Section 5.5).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.RecognizedPrincipal">
            <summary>
            Every principal URL in the ACL request MUST identify a principal resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.SetAclErrorDetails.AllowedPrincipal">
            <summary>
            The principals specified in the ACEs submitted in the ACL request MUST be
            allowed as principals for the resource. For example, a server where only authenticated principals can access
            resources would not allow the DAV:all or DAV:unauthenticated principals to be used in an ACE, since these
            would allow unauthenticated access to resources.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.SupportedPrivilege">
            <summary>
            Identifies the privileges defined for the resource.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.SupportedPrivilege.#ctor">
            <summary>
            Initializes a new instance of the SupportedPrivilege class.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.Privilege">
            <summary>
            Privilege that this object describes.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.IsAbstract">
            <summary>
            An abstract privilege MUST NOT be used in an ACE for that resource. Servers MUST fail an attempt to set an
            abstract privilege.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.Description">
            <summary>
            A description is a human-readable description of what this privilege controls access to.
            </summary>        
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.DescriptionLanguage">
            <summary>
            Language of description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.SupportedPrivilege.AggregatedPrivileges">
            <summary>
            Aggregate privileges list all of the privileges this privilege aggregates.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.WriteAce">
            <summary>
            Specifies the set of privileges to be either granted or denied to a single principal.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.Principal">
            <summary>
            Principal to which privileges are granted/denied.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.GrantPrivileges">
            <summary>
            Privileges granted by this ACE.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.WriteAce.DenyPrivileges">
            <summary>
            Privileges denied by this ACE.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode">
            <summary>
            Indicates which sharing or publishing capabilities are supported 
            by the calendar collection.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode.CanBeShared">
            <summary>
            Indicates that the calendar collection can be shared.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleAllowedSharingMode.CanBePublished">
            <summary>
            Indicates that the calendar collection can be published.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleShare">
            <summary>
            Describes sharing operation specific to Apple iCal.
            </summary>
            <remarks>The list of items of this type is passed to <see cref="M:ITHit.WebDAV.Server.CalDav.IAppleCalendar.UpdateSharing(System.Collections.Generic.IList{ITHit.WebDAV.Server.CalDav.AppleShare})"/> metod.</remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.AppleShare.FromXmlNode(System.Xml.XmlNode)">
            <summary>
            Parses node and sets AppleShere instance
            </summary>
            <param name="node"></param>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Operation">
            <summary>
            Describes sharing operation applied to calendar item.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Address">
            <summary>
            Principal-URL for a sharee hosted on the same server, a calendar user address or email address.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.CommonName">
            <summary>
            Name of the person to share calendar with.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.AppleShare.Summary">
            <summary>
            Summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.AppleSharingOperation">
            <summary>
            Describes sharing operations that are specific to Apple iCal
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.Read">
            <summary>
            Grant read privilage.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.ReadWrite">
            <summary>
            Grant read and write privilage.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.AppleSharingOperation.Withdraw">
            <summary>
            Withdraw access to the calendar.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.CalendarComponentType">
            <summary>
            Specifies the calendar component types (e.g., VEVENT, VTODO, etc.) 
            that calendar object resources can contain in the calendar collection.
            </summary>
            <remarks>
            For more details see: http://tools.ietf.org/html/rfc4791#section-5.2.3
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarComponentType.VEVENT">
            <summary>
            Event calendar component.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarComponentType.VTODO">
            <summary>
            To-do calendar component.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.CalendarSharedBy">
            <summary>
            Indicates that the calendar is shared and if it is shared by the current user who is the owner of the calendar.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.NotShared">
            <summary>
            Indicates that the calendar is not shared.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner">
            <summary>
            Indicates that the calendar is owned by the current user and is being shared by them.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared">
            <summary>
            Indicates that the calendar is owned by another user and is being shared to the current user.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarDiscovery">
            <summary>
            Assists in finding calendars on a CalDAV server. Enables <b>calendar-home-set</b> feature support discovery.
            </summary>
            <remarks>
            <para>
            This interface helps finding folders that contain calendars. You will implement this interface on principal items, 
            as well as on any other items that you wish to report <b>calendar-home-set</b> feature support and list folders that 
            contain calendars owned by currently logged-in user. 
            </para>
            <para>
            This interface provides <see cref="M:ITHit.WebDAV.Server.CalDav.ICalendarDiscovery.GetCalendarHomeSet"/>) method that is called by the Engine 
            when client is discovering list of folders that contain calendars.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class Discovery : IAddressbookDiscoveryAsync
{
    protected DavContext Context;

    public Discovery(DavContext context)
    {
        this.Context = context;
    }

    public async Task<IEnumerable<IItemCollectionAsync>> GetAddressbookHomeSetAsync()
    {
        return new[] { new AddressbooksRootFolder(Context) };
    }

    public bool AddressbookHomeSetEnabled
    {
        get
        {
            return true;
        }
    }
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class CalendarsRootFolder : LogicalFolder, IFolderAsync
{
    private static readonly string calendarsRootFolderName = "calendars";

    public static string CalendarsRootFolderPath = DavLocationFolder.DavLocationFolderPath + calendarsRootFolderName + '/';

    public CalendarsRootFolder(DavContext context)
        : base(context, CalendarsRootFolderPath)
    {
    }

    public override async Task<IEnumerable<IHierarchyItemAsync>> GetChildrenAsync(IList<PropertyName> propNames)
    {           
        // Here we list calendars from back-end storage. 
        // You can filter calendars if requied and return only calendars that user has access to.
        return (await CalendarFolder.LoadAllAsync(Context)).OrderBy(x => x.Name);
    }

    public Task<IFileAsync> CreateFileAsync(string name)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task CreateFolderAsync(string name)
    {
        await CalendarFolder.CreateCalendarFolderAsync(Context, name, "");
    }
}
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[// Note:
//  - Mozilla Thunderbird Lightning requires ICurrentUserPrincipalAsync on calendar folder, it does not support discovery.
//  - Outlook CalDAV Synchronizer requires IAclHierarchyItemAsync on calendar folder.

public class CalendarFolder : DavHierarchyItem, ICalendarFolderAsync, IAppleCalendarAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<ICalendarFolderAsync> LoadByIdAsync(DavContext context, Guid calendarFolderId)
    {
        // Load only calendar that the use has access to. 
        // Also load complete ACL for this calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access]
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId", context.UserId
            , "@CalendarFolderId", calendarFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<ICalendarFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only calendars that the use has access to. 
        // Also load complete ACL for each calendar, but only if user has access to that calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<ICalendarFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICalendarFolderAsync> calendarFolders = new List<ICalendarFolderAsync>();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))
        {
            DataTable calendars = new DataTable();
            calendars.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowCalendarFolder in calendars.Rows)
            {
                Guid calendarFolderId = rowCalendarFolder.Field<Guid>("CalendarFolderId");

                string filter = string.Format("CalendarFolderId = '{0}'", calendarFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                calendarFolders.Add(new CalendarFolder(context, calendarFolderId, rowCalendarFolder, rowsAccess));
            }
        }

        return calendarFolders;
    }

    public static async Task CreateCalendarFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create calendar.
        // 2. Grant owner privileges to the user on the created calendar.
        string sql = @"INSERT INTO [cal_CalendarFolder] (
                      [CalendarFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @CalendarFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [cal_Access] (
                      [CalendarFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @CalendarFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid calendarFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid calendarFolderId;

    private readonly DataRow rowCalendarFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowCalendarFolder != null ? rowCalendarFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId);
        }
    }

    private CalendarFolder(DavContext context, Guid calendarFolderId, DataRow calendar, DataRow[] rowsAccess)
        : base(context)
    {
        this.calendarFolderId = calendarFolderId;
        this.rowCalendarFolder = calendar;
        this.rowsAccess = rowsAccess;
    }

    public async Task<IEnumerable<ICalendarFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of UIDs from path list.
        IEnumerable<string> uids = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CalendarFile.LoadByUidsAsync(Context, uids, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICalendarFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList())).Cast<ICalendarFileAsync>();
    }

    public IEnumerable<CalendarComponentType> SupportedComponentTypes
    {
        get
        {
            return new[]
                {
                    CalendarComponentType.VEVENT,
                    CalendarComponentType.VTODO,
                };
        }
    }

    public string CalendarDescription 
    {
        get { return rowCalendarFolder.Field<string>("Description"); }
    }

    public ulong MaxResourceSize
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxInstances
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxAttendeesPerInstance
    {
        get { return ulong.MaxValue; }
    }

    public DateTime UtcMinDateTime
    {
        get { return DateTime.MinValue.ToUniversalTime(); }
    }

    public DateTime UtcMaxDateTime
    {
        get { return DateTime.MaxValue.ToUniversalTime(); }
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetChildrenAsync(IList<PropertyName> propNames)
    {
        // Here we enumerate all events and to-dos contained in this calendar.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync, that follow this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return await CalendarFile.LoadByCalendarFolderIdAsync(Context, calendarFolderId, PropsToLoad.Minimum);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual event or to-do object is created in datatbase in CardFile.Write call.
        return CalendarFile.CreateCalendarFile(Context, calendarFolderId);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only calendars renaming. Check that user has permissions to write.
        string sql = @"UPDATE [cal_CalendarFolder] SET Name=@Name
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , destName) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete calendar and all events / to-dos associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [cal_CalendarFolder] 
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [cal_CalendarFolderProperty] WHERE [CalendarFolderId] = @CalendarFolderId",
                "@CalendarFolderId", calendarFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();
        
        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))
        {
            while (reader.Read())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [cal_CalendarFolderProperty]
              WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , prop.QualifiedName.Name,
            "@Namespace"        , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [cal_CalendarFolderProperty] ([CalendarFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@CalendarFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [cal_CalendarFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [cal_CalendarFolderProperty]
                          WHERE [CalendarFolderId] = @CalendarFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , name,
            "@Namespace"        , ns);
    }


    public IEnumerable<AppleAllowedSharingMode> AllowedSharingModes
    {
        get
        {
            return new[]
                {
                    AppleAllowedSharingMode.CanBePublished,
                    AppleAllowedSharingMode.CanBeShared,
                };
        }
    }

    public async Task UpdateSharingAsync(IList<AppleShare> sharesToAddAndRemove)
    {
        // Drop all shares first regardless of operation order. When resending 
        // invitations Apple Calendar drops and adds shares for the user in one \
        // request.
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation == AppleSharingOperation.Withdraw)
            {
                // remove sharing here
                // share.Address
                // share.CommonName
            }
        }

        // Add new shares
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation != AppleSharingOperation.Withdraw)
            {
                // enable sharing and send invitation here
                // share.Address
                // share.CommonName
            }
        }
    }

    public async Task<IEnumerable<SharingInvite>> GetInviteAsync()
    {

        IList<SharingInvite> invites = new List<SharingInvite>();

        foreach (DataRow rowAccess in rowsAccess)
        {
            if (rowAccess.Field<bool>("Owner"))
                continue;

            string userId = rowAccess.Field<string>("UserId");
            System.Web.Security.MembershipUser user = System.Web.Security.Membership.GetUser(userId);

            SharingInvite ace = new SharingInvite
            {
                  Address       = string.Format("email:{0}", user.Email)
                , Access        = rowAccess.Field<bool>("Write") ? SharingInviteAccess.ReadWrite : SharingInviteAccess.Read
                , CommonName    = user.UserName
                , Status        = SharingInviteStatus.Accepted
            };
        }

        return invites;
    }

    public async Task<CalendarSharedBy> GetSharedByAsync()
    {
        if (rowsAccess.Any(x => !x.Field<bool>("Owner")))
        {
            return CalendarSharedBy.NotShared;
        }

        string ownerId = rowsAccess.First(x => x.Field<bool>("Owner")).Field<string>("UserId");
        if (ownerId.Equals(Context.UserId, StringComparison.InvariantCultureIgnoreCase))
        {
            return CalendarSharedBy.SharedByOwner;
        }
        else
        {
            return CalendarSharedBy.Shared;
        }
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId") == Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarItem">
            <summary>
            Represents folder, file or principal on a CalDAV server. Enables <b>calendar-access</b> feature support discovery.
            </summary>
            <remarks>
            <para>This is the marker interface, it does not provide any methods or properties.</para>
            <para>
            Items that implement this interface report CalDAV support in OPTIONS requests. 
            If this intervace is found on an item, the <b>DAV</b> header will include <b>calendar-access</b> token.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarDiscovery.GetCalendarHomeSet">
            <summary>
            Returns list of folder items that contain calendars owned by this principal.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            Note that this property returns list of folders that contain calendar folders, NOT the calendar folders themselves.
            </para>
            <para>
            http://tools.ietf.org/html/rfc4791#section-6.2.1
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarDiscovery.CalendarHomeSetEnabled">
            <summary>
            Returns <b>true</b> if <b>calendar-home-set</b> feature is enabled, <b>false</b> otherwise.
            </summary>
            <remarks>
            <para>
            In this method you can analyze User-Agent header to find out the client application used for accessing the server
            and enable/disable <b>calendar-home-set</b> feature for specific client. 
            </para>
            <para>
            iOS and OS X does require <b>calendar-home-set</b> feature to be always enabled. On the other hand it may consume extra 
            resources especially with iOS CalDAV client. iOS starts immediate synchronization of all calendars found on the server 
            via home-set request. Typically you will always enable home-set for iOS and OS X CalDAV clients, but may disable it for other clients.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarReport">
            <summary>
            Represents an item that can process <b>calendar-query</b> and <b>calendar-multiget</b> reports.
            </summary>
            <remarks>
            <para>
            Items that implement this interface advertise support for <b>calendar-query</b> and <b>calendar-multiget</b> 
            reports. 
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarReport.MultiGet(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets a list of calendar files that correspont to the specified list of item paths.
            </summary>
            <remarks>
            <para>
            This method is called by the Engine during <b>calendar-multiget</b> call.
            </para>
            <para>
            For each item from the <b>pathList</b> parameter return an item that corresponds to path or <b>null</b> if the item is not found.
            </para>
            </remarks>
            <param name="pathList">Calendar files path list.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files. Returns <b>null</b> for any item that is not found.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarReport.Query(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets a list of calendar files that match specified filter. 
            </summary>
            <param name="rawQuery">
            Raw query sent by the client.
            </param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarFolder">
            <summary>
            Represents a calendar on a CalDAV server.
            </summary>
            <remarks>
            <para>
            A calendar folder can contain calendar files only (items that implement 
            <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarFile"/>) and folders that are not <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarFolder"/> 
            folders. "Nesting" of calendar folders within other calendar folders at 
            any depth is NOT allowed.
            </para>
            <para>http://tools.ietf.org/html/rfc4791#section-4.2</para>
            </remarks>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[// Note:
//  - Mozilla Thunderbird Lightning requires ICurrentUserPrincipalAsync on calendar folder, it does not support discovery.
//  - Outlook CalDAV Synchronizer requires IAclHierarchyItemAsync on calendar folder.

public class CalendarFolder : DavHierarchyItem, ICalendarFolderAsync, IAppleCalendarAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<ICalendarFolderAsync> LoadByIdAsync(DavContext context, Guid calendarFolderId)
    {
        // Load only calendar that the use has access to. 
        // Also load complete ACL for this calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access]
              WHERE [CalendarFolderId] = @CalendarFolderId
              AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId", context.UserId
            , "@CalendarFolderId", calendarFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<ICalendarFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only calendars that the use has access to. 
        // Also load complete ACL for each calendar, but only if user has access to that calendar.
        string sql =
            @"SELECT * FROM [cal_CalendarFolder] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [cal_Access] 
              WHERE [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<ICalendarFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICalendarFolderAsync> calendarFolders = new List<ICalendarFolderAsync>();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))
        {
            DataTable calendars = new DataTable();
            calendars.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowCalendarFolder in calendars.Rows)
            {
                Guid calendarFolderId = rowCalendarFolder.Field<Guid>("CalendarFolderId");

                string filter = string.Format("CalendarFolderId = '{0}'", calendarFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                calendarFolders.Add(new CalendarFolder(context, calendarFolderId, rowCalendarFolder, rowsAccess));
            }
        }

        return calendarFolders;
    }

    public static async Task CreateCalendarFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create calendar.
        // 2. Grant owner privileges to the user on the created calendar.
        string sql = @"INSERT INTO [cal_CalendarFolder] (
                      [CalendarFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @CalendarFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [cal_Access] (
                      [CalendarFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @CalendarFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid calendarFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid calendarFolderId;

    private readonly DataRow rowCalendarFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowCalendarFolder != null ? rowCalendarFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId);
        }
    }

    private CalendarFolder(DavContext context, Guid calendarFolderId, DataRow calendar, DataRow[] rowsAccess)
        : base(context)
    {
        this.calendarFolderId = calendarFolderId;
        this.rowCalendarFolder = calendar;
        this.rowsAccess = rowsAccess;
    }

    public async Task<IEnumerable<ICalendarFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of UIDs from path list.
        IEnumerable<string> uids = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CalendarFile.LoadByUidsAsync(Context, uids, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICalendarFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList())).Cast<ICalendarFileAsync>();
    }

    public IEnumerable<CalendarComponentType> SupportedComponentTypes
    {
        get
        {
            return new[]
                {
                    CalendarComponentType.VEVENT,
                    CalendarComponentType.VTODO,
                };
        }
    }

    public string CalendarDescription 
    {
        get { return rowCalendarFolder.Field<string>("Description"); }
    }

    public ulong MaxResourceSize
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxInstances
    {
        get { return ulong.MaxValue; }
    }

    public ulong MaxAttendeesPerInstance
    {
        get { return ulong.MaxValue; }
    }

    public DateTime UtcMinDateTime
    {
        get { return DateTime.MinValue.ToUniversalTime(); }
    }

    public DateTime UtcMaxDateTime
    {
        get { return DateTime.MaxValue.ToUniversalTime(); }
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetChildrenAsync(IList<PropertyName> propNames)
    {
        // Here we enumerate all events and to-dos contained in this calendar.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync, that follow this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return await CalendarFile.LoadByCalendarFolderIdAsync(Context, calendarFolderId, PropsToLoad.Minimum);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual event or to-do object is created in datatbase in CardFile.Write call.
        return CalendarFile.CreateCalendarFile(Context, calendarFolderId);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only calendars renaming. Check that user has permissions to write.
        string sql = @"UPDATE [cal_CalendarFolder] SET Name=@Name
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId
            , "@Name"               , destName) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete calendar and all events / to-dos associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [cal_CalendarFolder] 
            WHERE [CalendarFolderId]=@CalendarFolderId
            AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@CalendarFolderId"   , calendarFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [cal_CalendarFolderProperty] WHERE [CalendarFolderId] = @CalendarFolderId",
                "@CalendarFolderId", calendarFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();
        
        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))
        {
            while (reader.Read())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [cal_CalendarFolderProperty]
              WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , prop.QualifiedName.Name,
            "@Namespace"        , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [cal_CalendarFolderProperty] ([CalendarFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@CalendarFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [cal_CalendarFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [CalendarFolderId] = @CalendarFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"          , prop.Value,
                "@CalendarFolderId" , calendarFolderId,
                "@Name"             , prop.QualifiedName.Name,
                "@Namespace"        , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [cal_CalendarFolderProperty]
                          WHERE [CalendarFolderId] = @CalendarFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@CalendarFolderId" , calendarFolderId,
            "@Name"             , name,
            "@Namespace"        , ns);
    }


    public IEnumerable<AppleAllowedSharingMode> AllowedSharingModes
    {
        get
        {
            return new[]
                {
                    AppleAllowedSharingMode.CanBePublished,
                    AppleAllowedSharingMode.CanBeShared,
                };
        }
    }

    public async Task UpdateSharingAsync(IList<AppleShare> sharesToAddAndRemove)
    {
        // Drop all shares first regardless of operation order. When resending 
        // invitations Apple Calendar drops and adds shares for the user in one \
        // request.
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation == AppleSharingOperation.Withdraw)
            {
                // remove sharing here
                // share.Address
                // share.CommonName
            }
        }

        // Add new shares
        foreach (AppleShare share in sharesToAddAndRemove)
        {
            if (share.Operation != AppleSharingOperation.Withdraw)
            {
                // enable sharing and send invitation here
                // share.Address
                // share.CommonName
            }
        }
    }

    public async Task<IEnumerable<SharingInvite>> GetInviteAsync()
    {

        IList<SharingInvite> invites = new List<SharingInvite>();

        foreach (DataRow rowAccess in rowsAccess)
        {
            if (rowAccess.Field<bool>("Owner"))
                continue;

            string userId = rowAccess.Field<string>("UserId");
            System.Web.Security.MembershipUser user = System.Web.Security.Membership.GetUser(userId);

            SharingInvite ace = new SharingInvite
            {
                  Address       = string.Format("email:{0}", user.Email)
                , Access        = rowAccess.Field<bool>("Write") ? SharingInviteAccess.ReadWrite : SharingInviteAccess.Read
                , CommonName    = user.UserName
                , Status        = SharingInviteStatus.Accepted
            };
        }

        return invites;
    }

    public async Task<CalendarSharedBy> GetSharedByAsync()
    {
        if (rowsAccess.Any(x => !x.Field<bool>("Owner")))
        {
            return CalendarSharedBy.NotShared;
        }

        string ownerId = rowsAccess.First(x => x.Field<bool>("Owner")).Field<string>("UserId");
        if (ownerId.Equals(Context.UserId, StringComparison.InvariantCultureIgnoreCase))
        {
            return CalendarSharedBy.SharedByOwner;
        }
        else
        {
            return CalendarSharedBy.Shared;
        }
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId") == Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.IFolder">
            <summary>
            Represents a folder in the WebDAV repository.
            </summary>
            <remarks>
            Defines the properties and methods that WebDAV server folder objects must implement.
            In addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> and <see cref="T:ITHit.WebDAV.Server.IItemCollection"/> this interface also provides
            methods for creating WebDAV items (folders and files).
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class1.IFolder.CreateFile(System.String)">
            <summary>
            Creates new WebDAV file with the specified name in this folder.
            </summary>
            <returns>
            .
            </returns>
            <param name="name">Name of the file to create.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>You must create a file in your repository during this call. After calling this method Engine calls
            <see cref="M:ITHit.WebDAV.Server.IContent.Write(System.IO.Stream,System.String,System.Int64,System.Int64)"/>.</remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IFolder.CreateFile&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class1.IFolder.CreateFolder(System.String)">
            <summary>
            Creates new WebDAV folder with the specified name in this folder.
            </summary>
            <returns>
            .
            </returns>
            <param name="name">Name of the folder to create.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IFolder.CreateFolder&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.SupportedComponentTypes">
            <summary>
            Gets a calendar component types (e.g., VEVENT, VTODO, etc.) 
            that calendar object resources can contain in the calendar collection.        
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.3
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.CalendarDescription">
            <summary>
            Gets a human-readable description of the calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.1
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.MaxResourceSize">
            <summary>
            Gets a numeric value indicating the maximum size of a
            resource in bytes that the server is willing to accept when a
            calendar object resource is stored in a calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.5
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.MaxInstances">
            <summary>
            Gets a numeric value indicating the maximum number of
            recurrence instances that a calendar object resource stored in a
            calendar collection can generate.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.8
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.MaxAttendeesPerInstance">
            <summary>
            Provides a numeric value indicating the maximum number of
            ATTENDEE properties in any instance of a calendar object resource
            stored in a calendar collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.9
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.UtcMinDateTime">
            <summary>
            Gets a DATE-TIME value indicating the earliest date and
            time (in UTC) that the server is willing to accept for any DATE or
            DATE-TIME value in a calendar object resource stored in a calendar
            collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.6
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.ICalendarFolder.UtcMaxDateTime">
            <summary>
            Gets a DATE-TIME value indicating the latest date and
            time (in UTC) that the server is willing to accept for any DATE or
            DATE-TIME value in a calendar object resource stored in a calendar
            collection.
            </summary>
            <remarks>
            More details at http://tools.ietf.org/html/rfc4791#section-5.2.7
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ICalendarSynchronization.Synchronize(System.String,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Gets a list of calendar files that changed since provided <b>syncToken</b>.
            </summary>
            <param name="syncToken">Synchronization token sent by the client.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of calendar files.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipal">
            <summary>
            Represents principal on a CalDAV server with Scheduling Extensions support. Enables <b>calendar-auto-schedule</b> feature support discovery.
            </summary>
            <remarks>
            <para>
            Items that implement this interface report CalDAV Scheduling Extensions support in OPTIONS requests. 
            If this intervace is found on an item, the DAV header will include <b>calendar-auto-schedule</b> token.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarPrincipal">
            <summary>
            Represents principal on a server that supports CalDAV.
            </summary>
            <remarks>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipal"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces.  
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipal.GetCalendarUserAddressSet">
            <summary>
            Gets the list of calendar addresses, typically e-mails, for this principal resource.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipal.GetScheduleOutboxUrl">
            <summary>
            Gets the URL of the scheduling outbox collection owned by this principal.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.ISchedulingPrincipal.GetScheduleInboxUrl">
            <summary>
            Gets the URL of the scheduling inbox collection owned by this principal.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInviteAccess">
            <summary>
            Shared calendar access level privilege.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteAccess.Read">
            <summary>
            Indicates that the access level granted only allows sharees to read data in the shared calendar.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteAccess.ReadWrite">
            <summary>
            Indicates that the access level granted allows sharees to read and write all data in the shared calendar, with the exception of components that would trigger scheduling.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IAppleCalendar">
            <summary>
            Calendars that imlement this interface support calendar 
            sharing from iCal on iOS and Mac OS X. Enables <b>calendarserver-sharing</b> feature support discovery.
            </summary>
            <remarks>
            <para>
            Adding this interace on calendar item 
            enables 'Share Calendar' menu option in Calendar on iOS and Mac OS X.
            </para>
            <para>
            Items with this interface will add <b>calendarserver-sharing</b> token to <b>DAV</b> header on OPTIONS requests.
            </para>
            <para>http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt</para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendar.UpdateSharing(System.Collections.Generic.IList{ITHit.WebDAV.Server.CalDav.AppleShare})">
            <summary>
            This metod is called when user is granting or 
            withdrowing acces to the calendar. 
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            In this metod implementation you will grant 
            or withdraw acces to the calendar as well as you will send sharing invitation.
            </para>
            <para>
            When user is updating acces rights, for example changing 
            acces rights from read-write to read-only the Apple iCal client application 
            submits 'delete share' and 'add share' with new access rights in a  
            single request. Your implementation must first delete all shares and 
            than add new shares regardless of the order they are sent and listed 
            in <see href="sharesToAddAndRemove"/> parameter.
            </para>
            <para>http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt</para>
            </remarks>
            <param name="sharesToAddAndRemove">Each item in this list describes the share to 
            add or delete.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendar.GetInvite">
            <summary>
            Provides a list of users to whom the calendar has been shared.
            </summary>
            <remarks>
            <para>
            If calendar is shared, in addition to the list of <see cref="T:ITHit.WebDAV.Server.CalDav.SharingInvite"/> it must return 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner"/> if the current user is the owner of this calendar or 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared"/> for any other user with whom this calendar is shared.
            </para>
            <para>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.2)
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CalDav.IAppleCalendar.GetSharedBy">
            <summary>
            Indicates that the calendar is shared and if it is shared by owner.
            </summary>
            <remarks>
            <para>
            If calendar is shared, it must return 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.SharedByOwner"/> if the current user is the owner of this calendar or 
            <see cref="F:ITHit.WebDAV.Server.CalDav.CalendarSharedBy.Shared"/> for any other user with whom this calendar is shared.
            </para>
            <para>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.1)  
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.IAppleCalendar.AllowedSharingModes">
            <summary>
            Indicates which sharing or publishing capabilities are supported 
            by this calendar collection.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IScheduleInboxFolder">
            <summary>
            Represents scheduling inbox folder.
            </summary>
            <remarks>
            <para>
            This is the marker interface, it does not add any new methods in addition 
            to provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFolder"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces. Items that impement this interface report 
            <b>calendar-auto-schedule</b> support in response to the OPTIONS request in DAV header.
            </para>
            <para>Folders of this type contain copies of incoming scheduling messages.</para>
            <para>Scheduling inbox folder can not contain any other folders.</para>
            <para>More details could be found at http://tools.ietf.org/html/rfc6638#section-2.2</para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.ICalendarFile">
            <summary>
            Represents calendar file. 
            </summary>
            <remarks>
            <para>
            Items of this type will return content returned from 
            <see cref="M:ITHit.WebDAV.Server.IContent.Read(System.IO.Stream,System.Int64,System.Int64)"/> method in <b>calendar-data</b> 
            CalDAV property.
            </para>
            <para>
            This is the marker interface, it does not provide any methods or properties in 
            addition to methods and properties provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces.
            </para>
            <para>
            Calendar file contains definition of the calendar resource in the iCalendar format. 
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'CalDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[

// +--- Calendar file [UID1].ics ---------+
// |                                      |
// |  +-- Time zone component ---------+  | -- Time zones are are not stored in DB, they are generated automatically 
// |  | TZID: Zone X                   |  |    during serialization, based on TZIDs found in event or to-do.
// |  | ...                            |  |
// |  +--------------------------------+  |
// |                                      |
// |  +-- Time zone component ---------+  |
// |  | TZID: Zone Y                   |  | -- Time zone IDs could be either IANA (Olson) IDs or System (Windows) IDs.
// |  | ...                            |  |
// |  +--------------------------------+  |
// |  ...                                 |
// |                                      |
// |                                      |
// |  +-- Event component -------------+  | -- Event / do-do components are stored in [cal_EventComponent] table.
// |  | UID: [UID1]                    |  |    
// |  | RRULE: FREQ=DAILY              |  | 
// |  | SUMMARY: Event A               |  |
// |  | ...                            |  |
// |  +--------------------------------+  |
// |                                      |
// |  +-- Event component -------------+  | -- In case of recurring events/to-dos there could be more than one component
// |  | UID: [UID1]                    |  |    per file. All event/to-do components within a single calendar file share
// |  | RECURRENCE-ID: 20151028        |  |    the same UID but have different RECURRENCE-IDs. 
// |  | SUMMARY: Instance 5 of Event A |  |    
// |  | ...                            |  |    iOS / OS X UIDs are case sensitive (uppercase GUIDs).
// |  +--------------------------------+  |    Bynari WebDAV Collaborator for MS Outlook UIDs are over 100 chars in length.
// |  ...                                 |
// |                                      |
// |                                      |
// +--------------------------------------+
// 
// 
// 
//    +-- Event component -------------+
//    |                                |
//    | UID: [UID1]                    | 
//    | SUMMARY: Event A               |
//    | START: 20151016T080000         |
//    | RRULE: FREQ=DAILY              |
//    | ...                            |
//    |                                |
//    | EXDATE: 20151018T080000        | -- Recurrence exception dates are stored in [cal_RecurrenceException] table.
//    | EXDATE: 20151020T080000        |
//    | ...                            |
//    |                                |
//    | ATTENDEE: mail1@server.com     | -- Attendees are stored in [cal_Attendee] table.
//    | ATTENDEE: mail2@srvr.com       |
//    | ...                            |
//    |                                |
//    | ATTACH: /9j/4VGuf+Sw...        | -- Attachments are stored in [cal_Attachment] table.
//    | ATTACH: https://serv/file.docx |
//    | ...                            |
//    |                                |
//    |  +-- Alarm Component -------+  | -- Alarms are stored in [cal_Alarm] table.
//    |  | ACTION: DISPLAY          |  |
//    |  | ...                      |  |
//    |  +--------------------------+  |
//    |                                |
//    |  +-- Alarm Component -------+  |
//    |  | ACTION: EMAIL            |  |
//    |  | ...                      |  |
//    |  +--------------------------+  |
//    |  ...                           |
//    |                                |
//    +--------------------------------+

public class CalendarFile : DavHierarchyItem, ICalendarFileAsync
{
    public static string Extension = ".ics";

    public static async Task<IEnumerable<ICalendarFileAsync>> LoadByCalendarFolderIdAsync(DavContext context, Guid calendarFolderId, PropsToLoad propsToLoad)
    {
        // propsToLoad == PropsToLoad.Minimum -> Typical GetChildren call by iOS, Android, eM Client, etc CalDAV clients
        // [Summary] is typically not required in GetChildren call, 
        // they are extracted for demo purposes only, to be displayed in Ajax File Browser.

        // propsToLoad == PropsToLoad.All -> Bynari call, it requires all props in GetChildren call.

        if (propsToLoad != PropsToLoad.Minimum)
            throw new NotImplementedException("LoadByCalendarFolderIdAsync is implemented only with PropsToLoad.Minimum.");

        string sql = @"SELECT * FROM [cal_CalendarFile] 
                       WHERE [CalendarFolderId] = @CalendarFolderId
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)

                      ;SELECT [UID], [Summary] FROM [cal_EventComponent] 
                       WHERE [UID] IN (SELECT [UID] FROM [cal_CalendarFile] 
                                       WHERE [CalendarFolderId] = @CalendarFolderId)";

        sql = string.Format(sql, GetScPropsToLoad(propsToLoad));
        
        return await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@CalendarFolderId"   , calendarFolderId);
    }

    public static async Task<IEnumerable<ICalendarFileAsync>> LoadByUidsAsync(DavContext context, IEnumerable<string> uids, PropsToLoad propsToLoad)
    {
        // Get IN clause part with list of file UIDs for SELECT.
        string selectIn = string.Join(", ", uids.Select(a => string.Format("'{0}'", a)).ToArray());

        string sql = @"SELECT * FROM [cal_CalendarFile] 
                       WHERE [UID] IN ({1})
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId)";

        if(propsToLoad==PropsToLoad.All)
        {
            // Here we do not select attachments content because it could be very large,
            // we only set [ContentExists] flag marking that it should be loaded during IContent.ReadAsync call.
            sql += @";SELECT * FROM [cal_EventComponent]      WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_RecurrenceException] WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_Alarm]               WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_Attendee]            WHERE [UID] IN ({1})
                     ;SELECT * FROM [cal_CustomProperty]      WHERE [UID] IN ({1})
                     ;SELECT [AttachmentId], [EventComponentId], [UID], [MediaType], [ExternalUrl], 
                         (CASE WHEN [Content] IS NULL THEN 0 ELSE 1 END) AS [ContentExists] 
                               FROM [cal_Attachment]          WHERE [UID] IN ({1})";
        }

        sql = string.Format(sql, GetScPropsToLoad(propsToLoad), selectIn);

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<ICalendarFileAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICalendarFileAsync> items = new List<ICalendarFileAsync>();

        Stopwatch stopWatch = Stopwatch.StartNew();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))
        {
            DataTable calendarFiles = new DataTable();
            calendarFiles.Load(reader);

            DataTable eventComponents = new DataTable();
            if (!reader.IsClosed)
                eventComponents.Load(reader);

            DataTable recurrenceExceptions = new DataTable();
            if (!reader.IsClosed)
                recurrenceExceptions.Load(reader);

            DataTable alarms = new DataTable();
            if (!reader.IsClosed)
                alarms.Load(reader);

            DataTable attendees = new DataTable();
            if (!reader.IsClosed)
                attendees.Load(reader);

            DataTable customProperties = new DataTable();
            if (!reader.IsClosed)
                customProperties.Load(reader);

            DataTable attachments = new DataTable();
            if (!reader.IsClosed)
                attachments.Load(reader);


            stopWatch.Stop();
            context.Engine.Logger.LogDebug(string.Format("SQL took: {0}ms", stopWatch.ElapsedMilliseconds));


            foreach (DataRow rowCalendarFile in calendarFiles.Rows)
            {
                DataRow[] rowsEventComponents      = new DataRow[0];
                DataRow[] rowsRecurrenceExceptions = new DataRow[0];
                DataRow[] rowsAlarms               = new DataRow[0];
                DataRow[] rowsAttendees            = new DataRow[0];
                DataRow[] rowsCustomProperties     = new DataRow[0];
                DataRow[] rowsAttachments          = new DataRow[0];

                string uid = rowCalendarFile.Field<string>("UID");

                string filter = string.Format("UID = '{0}'", uid);

                if (eventComponents.Columns["UID"] != null)
                    rowsEventComponents = eventComponents.Select(filter);
                if (recurrenceExceptions.Columns["UID"] != null)
                    rowsRecurrenceExceptions = recurrenceExceptions.Select(filter);
                if (alarms.Columns["UID"] != null)
                    rowsAlarms = alarms.Select(filter);
                if (attendees.Columns["UID"] != null)
                    rowsAttendees = attendees.Select(filter);
                if (customProperties.Columns["UID"] != null)
                    rowsCustomProperties = customProperties.Select(filter);
                if (attachments.Columns["UID"] != null)
                    rowsAttachments = attachments.Select(filter);

                items.Add(new CalendarFile(context, uid, rowCalendarFile, rowsEventComponents, rowsRecurrenceExceptions, rowsAlarms, rowsAttendees, rowsCustomProperties, rowsAttachments));
            }
        }

        return items;
    }

    private static string GetScPropsToLoad(PropsToLoad propsToLoad)
    {
        switch (propsToLoad)
        {
            case PropsToLoad.None:
                return "[UID]";
            case PropsToLoad.Minimum:
                // [Summary] is typically not required in GetChildren call, 
                // they are extracted for demo purposes only, to be displayed in Ajax File Browser as a file display name.
                return "[UID], [Summary]";
            case PropsToLoad.All:
                return "*";
        }
        throw new Exception("Should never come here.");
    }

    public static CalendarFile CreateCalendarFile(DavContext context, Guid calendarFolderId)
    {
        CalendarFile calendarFile = new CalendarFile(context, null, null, null, null, null, null, null, null);
        calendarFile.calendarFolderId = calendarFolderId;
        return calendarFile;
    }

    private readonly string uid = null;

    private readonly DataRow rowCalendarFile = null;

    private readonly DataRow[] rowsEventComponents = null;

    private readonly DataRow[] rowsRecurrenceExceptions = null;

    private readonly DataRow[] rowsAlarms = null;

    private readonly DataRow[] rowsAttendees = null;

    private readonly DataRow[] rowsCustomProperties = null;

    private readonly DataRow[] rowsAttachments = null;

    private bool isNew
    {
        get { return calendarFolderId != Guid.Empty; }
    }

    private int paramIndex = 0;

    private Guid calendarFolderId = Guid.Empty;

    public override string Name
    {
        get
        {
            // Show all components summaries contained in this file.
            return string.Join(", ", rowsEventComponents.Select(x => string.Format("[{0}]", x.Field<string>("Summary"))).ToArray());
        }
    }

    public override string Path
    {
        get
        {
            Guid calendarFolderId = rowCalendarFile.Field<Guid>("CalendarFolderId");
            string uid              = rowCalendarFile.Field<string>("UID");
            return string.Format("{0}{1}/{2}{3}", CalendarsRootFolder.CalendarsRootFolderPath, calendarFolderId, uid, Extension);
        }
    }

    public string Etag
    {
        get
        {
            byte[] bETag = rowCalendarFile.Field<byte[]>("ETag");
            return BitConverter.ToUInt64(bETag.Reverse().ToArray(), 0).ToString(); // convert timestamp value to number
        }
    }

    public override DateTime Created
    {
        get { return rowCalendarFile.Field<DateTime>("CreatedUtc"); }
    }

    public override DateTime Modified
    {
        get { return rowCalendarFile.Field<DateTime>("ModifiedUtc"); }
    }

    public long ContentLength
    {
        get { return -1; }
    }

    public string ContentType
    {
     get { return "text/calendar"; }
    }

    private CalendarFile(DavContext context, string uid,
        DataRow rowCalendarFile, DataRow[] rowsEventComponents, DataRow[] rowsRecurrenceExceptions, DataRow[] rowsAlarms,
        DataRow[] rowsAttendees, DataRow[] rowsCustomProperties, DataRow[] rowsAttachments)
        : base(context)
    {
        this.uid                      = uid;
        this.rowCalendarFile          = rowCalendarFile;
        this.rowsEventComponents      = rowsEventComponents;
        this.rowsRecurrenceExceptions = rowsRecurrenceExceptions;
        this.rowsAlarms               = rowsAlarms;
        this.rowsAttendees            = rowsAttendees;
        this.rowsCustomProperties     = rowsCustomProperties;
        this.rowsAttachments          = rowsAttachments;
    }

    public async Task<bool> WriteAsync(Stream stream, string contentType, long startIndex, long totalFileSize)
    {
        //Set timeout to maximum value to be able to upload iCalendar files with large file attachments.
        System.Web.HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
        string iCalendar;
        using (StreamReader reader = new StreamReader(stream))
        {
            iCalendar = reader.ReadToEnd();
        }

        // Typically the stream contains a single iCalendar that contains one or more event or to-do components.
        IEnumerable<IComponent> calendars = new vFormatter().Deserialize(iCalendar);
        ICalendar2 calendar = calendars.First() as ICalendar2;

        IEnumerable<IEventBase> components = calendar.Events.Cast<IEventBase>();
        if (!components.Any())
        {
            components = calendar.ToDos.Cast<IEventBase>();
        }

        if (components == null)
            throw new DavException("Event or to-do was expected in the input stream, no events or to-dos were found.", DavStatus.UNSUPPORTED_MEDIA_TYPE);

        // All components inside calendar file has the same UID which is equal to file name.
        string uid = components.First().Uid.Text;

        // Save data to [cal_CalendarFile] table.
        await WriteCalendarFileAsync(Context, uid, calendarFolderId, isNew);

        foreach (IEventBase component in components)
        {
            Guid eventComponentId = Guid.NewGuid();

            // Save data to [cal_EventComponent] table.
            await WriteEventComponentAsync(Context, component, eventComponentId, uid);

            // Save recurrence days exceptions for recurring events and to-dos. 
            await WriteRecurrenceExceptionsAsync(Context, component.ExceptionDateTimes, eventComponentId, uid);

            // Save alarms.
            await WriteAlarmsAsync(Context, component.Alarms, eventComponentId, uid);

            // Save attengees.
            await WriteAttendeesAsync(Context, component.Attendees, eventComponentId, uid);

            // Save attachments.
            await WriteAttachmentsAsync(Context, component.Attachments, eventComponentId, uid);
        }

        // Notify attendees that event is created or modified.
        calendar.Method = calendar.CreateMethodProp(MethodType.Request);
        await iMipEventSchedulingTransport.NotifyAttendeesAsync(Context, calendar);

        return true;
    }

    private static async Task WriteCalendarFileAsync(DavContext context, string uid, Guid calendarFolderId, bool isNew)
    {
        string sql;
        if (isNew)
        {
            sql =
              @"IF EXISTS (SELECT 1 FROM [cal_Access] WHERE [CalendarFolderId]=@CalendarFolderId AND [UserId]=@UserId AND [Write]=1)
                INSERT INTO [cal_CalendarFile] (
                      [UID]
                    , [CalendarFolderId]
                ) VALUES (
                      @UID
                    , @CalendarFolderId
                )";
        }
        else
        {
            // We can only update record in [cal_CalendarFile] table.
            // There is no way to update [cal_EventComponent], [cal_RecurrenceException], [cal_Alarm], [cal_Attendee], 
            // [cal_Attachment] and [cal_CustomProperty] for existing event, we must delete all records for this UID and recreate.

            // [ModifiedUtc] field update triggers [ETag] field update which is used for synchronyzation.
            sql =
              @"IF EXISTS (SELECT 1 FROM [cal_CalendarFile]
                    WHERE UID = @UID
                    AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId] = @UserId AND [Write] = 1))
                BEGIN
                    UPDATE [cal_CalendarFile] SET 
                        [ModifiedUtc] = @ModifiedUtc
                    WHERE [UID] = @UID

                    ; DELETE FROM [cal_EventComponent]      WHERE [UID] = @UID
                    ; DELETE FROM [cal_RecurrenceException] WHERE [UID] = @UID
                    ; DELETE FROM [cal_Alarm]               WHERE [UID] = @UID
                    ; DELETE FROM [cal_Attendee]            WHERE [UID] = @UID
                    ; DELETE FROM [cal_Attachment]          WHERE [UID] = @UID
                    ; DELETE FROM [cal_CustomProperty]      WHERE [UID] = @UID
                END";
        }

        if(await context.ExecuteNonQueryAsync(sql,
              "@UID"                , uid
            , "UserId"              , context.UserId
            , "@CalendarFolderId"   , calendarFolderId
            , "@ModifiedUtc"        , DateTime.UtcNow) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    private async Task WriteEventComponentAsync(DavContext context, IEventBase sc, Guid eventComponentId, string uid)
    {
        string sql =
                @"INSERT INTO [cal_EventComponent] (
                      [EventComponentId]
                    , [UID]
                    , [ComponentType]
                    , [DateTimeStampUtc]
                    , [CreatedUtc]
                    , [LastModifiedUtc]
                    , [Summary]
                    , [Description]
                    , [OrganizerEmail]
                    , [OrganizerCommonName]
                    , [Start]
                    , [StartTimeZoneId]
                    , [End]
                    , [EndTimeZoneId]
                    , [Duration]
                    , [AllDay]
                    , [Class]
                    , [Location]
                    , [Priority]
                    , [Sequence]
                    , [Status]
                    , [Categories]
                    , [RecurFrequency]
                    , [RecurInterval]
                    , [RecurUntil]
                    , [RecurCount]
                    , [RecurWeekStart]
                    , [RecurByDay]
                    , [RecurByMonthDay]
                    , [RecurByMonth]
                    , [RecurBySetPos]
                    , [RecurrenceIdDate]
                    , [RecurrenceIdTimeZoneId]
                    , [RecurrenceIdThisAndFuture]
                    , [EventTransparency]
                    , [ToDoCompletedUtc]
                    , [ToDoPercentComplete]
                ) VALUES (
                      @EventComponentId
                    , @UID
                    , @ComponentType
                    , @DateTimeStampUtc 
                    , @CreatedUtc
                    , @LastModifiedUtc
                    , @Summary
                    , @Description
                    , @OrganizerEmail
                    , @OrganizerCommonName
                    , @Start, @StartTimeZoneId
                    , @End, @EndTimeZoneId
                    , @Duration
                    , @AllDay
                    , @Class
                    , @Location
                    , @Priority
                    , @Sequence
                    , @Status
                    , @Categories
                    , @RecurFrequency
                    , @RecurInterval
                    , @RecurUntil
                    , @RecurCount
                    , @RecurWeekStart
                    , @RecurByDay
                    , @RecurByMonthDay
                    , @RecurByMonth
                    , @RecurBySetPos
                    , @RecurrenceIdDate
                    , @RecurrenceIdTimeZoneId
                    , @RecurrenceIdThisAndFuture
                    , @EventTransparency
                    , @ToDoCompletedUtc
                    , @ToDoPercentComplete
                )";


        bool isEvent = sc is IEvent;

        // Get END in case of event or DUE in case of to-do component. 
        ICalDate endProp = isEvent ? (sc as IEvent).End : (sc as IToDo).Due;
        
        await context.ExecuteNonQueryAsync(sql,
              "@EventComponentId"       , eventComponentId
            , "@UID"                    , uid                                                                   // UID value
            , "@ComponentType"          , isEvent
            , "@DateTimeStampUtc"       , sc.DateTimeStampUtc?.Value?.DateVal                                   // DTSTAMP value
            , "@CreatedUtc"             , sc.CreatedUtc?.Value?.DateVal                                         // CREATED value
            , "@LastModifiedUtc"        , sc.LastModifiedUtc?.Value?.DateVal                                    // LAST-MODIFIED value
            , "@Summary"                , sc.Summary?.Text                                                      // SUMMARY value
            , "@Description"            , sc.Description?.Text                                                  // DESCRIPTION value
            , "@OrganizerEmail"         , sc.Organizer?.Uri?.Replace("mailto:", "")                             // ORGANIZER value
            , "@OrganizerCommonName"    , sc.Organizer?.CommonName                                              // ORGANIZER CN param
            , "@Start"                  , sc.Start?.Value?.DateVal                                              // DTSTART value
            , "@StartTimeZoneId"        , sc.Start?.Value?.DateVal.Kind == DateTimeKind.Utc ? TimeZoneInfo.Utc.Id : sc.Start?.TimeZoneId  // DTSTART TZID param
            , "@End"                    , endProp?.Value?.DateVal                                               // DTEND or DUE value
            , "@EndTimeZoneId"          , endProp?.Value?.DateVal.Kind == DateTimeKind.Utc ? TimeZoneInfo.Utc.Id : endProp?.TimeZoneId    // DTEND or DUE TZID param
            , "@Duration"               , sc.Duration?.Value?.Ticks                                             // DURATION value
            , "@AllDay"                 , !sc.Start?.Value?.Components.HasFlag(DateComponents.Time) // Check if start contains the time part to determine if this is a all-day event/to-do.
            , "@Class"                  , sc.Class?.Value.Name                                                  // CLASS value
            , "@Location"               , sc.Location?.Text                                                     // LOCATION value
            , "@Priority"               , sc.Priority?.Value                                                    // PRIORITY value
            , "@Sequence"               , sc.Sequence?.Value                                                    // SEQUENCE value
            , "@Status"                 , sc.Status?.Value.Name                                                 // STATUS value
            , "@Categories"             , ListToString<string>(sc.Categories.Select(x => ListToString<string>(x.Categories, ",")), ";") // CATEGORIES value
            , "@RecurFrequency"         , sc.RecurrenceRule?.Frequency?.ToString()                              // RRULE FREQ value part
            , "@RecurInterval"          , (int?)sc.RecurrenceRule?.Interval                                     // RRULE INTERVAL value part
            , "@RecurUntil"             , sc.RecurrenceRule?.Until?.DateVal                                     // RRULE UNTIL value part
            , "@RecurCount"             , (int?)sc.RecurrenceRule?.Count                                        // RRULE COUNT value part
            , "@RecurWeekStart"         , sc.RecurrenceRule?.WeekStart?.ToString()                              // RRULE WKST value part
            , "@RecurByDay"             , ListToString<DayRule>(sc.RecurrenceRule?.ByDay)                       // RRULE BYDAY value part
            , "@RecurByMonthDay"        , ListToString<short>(sc.RecurrenceRule?.ByMonthDay)                    // RRULE BYMONTHDAY value part
            , "@RecurByMonth"           , ListToString<ushort>(sc.RecurrenceRule?.ByMonth)                      // RRULE BYMONTH value part
            , "@RecurBySetPos"          , ListToString<short>(sc.RecurrenceRule?.BySetPos)                      // RRULE BYSETPOS value part
            , "@RecurrenceIdDate"       , sc.RecurrenceId?.Value.DateVal                                        // RECURRENCE-ID value
            , "@RecurrenceIdTimeZoneId" , sc.RecurrenceId?.TimeZoneId                                           // RECURRENCE-ID TZID param
            , "@RecurrenceIdThisAndFuture", sc.RecurrenceId?.IsThisAndFuture                                    // RECURRENCE-ID RANGE param
            , "@EventTransparency"      , (sc as IEvent)?.Transparency?.IsTransparent                           // VEVENT TRANSP value
            , "@ToDoCompletedUtc"       , (sc as IToDo)?.CompletedUtc?.Value?.DateVal                           // VTODO COMPLETED value
            , "@ToDoPercentComplete"    , (sc as IToDo)?.PercentComplete?.Value                                 // VTODO PERCENT-COMPLETE value
            );

        // Save custom properties and parameters of this component to [cal_CustomProperty] table.
        string customPropsSqlInsert;
        List<object> customPropsParamsInsert;
        if (PrepareSqlCustomPropertiesOfComponentAsync(sc, eventComponentId, uid, out customPropsSqlInsert, out customPropsParamsInsert))
        {
            await context.ExecuteNonQueryAsync(customPropsSqlInsert, customPropsParamsInsert.ToArray());
        }
    }

    private static string ListToString<T>(IEnumerable<T> arr, string separator = ",")
    {
        if ((arr == null) || !arr.Any())
            return null;
        return string.Join<T>(separator, arr);
    }

    private static async Task WriteRecurrenceExceptionsAsync(DavContext context, IPropertyList<ICalDateList> recurrenceExceptions, Guid eventComponentId, string uid)
    {
        // Typically CalDAV clients pass a single date value per EXDATE property.

        string sql =
            @"INSERT INTO [cal_RecurrenceException] (
                  [EventComponentId]
                , [UID]
                , [ExceptionDate]
                , [TimeZoneId]
                , [AllDay]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
              "@EventComponentId", eventComponentId
            , "@UID", uid
        });

        int i = 0;
        foreach (ICalDateList dateListProp in recurrenceExceptions)
        {
            foreach (Date date in dateListProp.Dates)
            {
                if (date == null)
                    continue; // failed fo parse date

                valuesSql.Add(string.Format(@"(
                  @EventComponentId
                , @UID
                , @ExceptionDate{0}
                , @TimeZoneId{0}
                , @AllDay{0}
                )", i));

                parameters.AddRange(new object[] {
              //  "@EventComponentId"
              //  "@UID" added for performance optimization purposes
                  "@ExceptionDate" +i, date.DateVal                                                                         // EXDATE value
                , "@TimeZoneId"    +i, date.DateVal.Kind == DateTimeKind.Utc ? TimeZoneInfo.Utc.Id : dateListProp.TimeZoneId// EXDATE TZID param
                , "@AllDay"        +i, !date.Components.HasFlag(DateComponents.Time)                                        // EXDATE DATE or DATE-TIME
                });
            }
            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAlarmsAsync(DavContext context, IComponentList<IAlarm> alarms, Guid eventComponentId, string uid)
    {
        string sql =
            @"INSERT INTO [cal_Alarm] (
                  [AlarmId]
                , [EventComponentId]
                , [UID]
                , [Action]
                , [TriggerAbsoluteDateTimeUtc]
                , [TriggerRelativeOffset]
                , [TriggerRelatedStart]
                , [Summary]
                , [Description]
                , [Duration]
                , [Repeat]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
              "@EventComponentId", eventComponentId
            , "@UID", uid
        });

        int i = 0;
        foreach (IAlarm alarm in alarms)
        {
            Guid alarmId = Guid.NewGuid();

            valuesSql.Add(string.Format(@"(
                  @AlarmId{0}
                , @EventComponentId
                , @UID
                , @Action{0}
                , @TriggerAbsoluteDateTimeUtc{0}
                , @TriggerRelativeOffset{0}
                , @TriggerRelatedStart{0}
                , @Summary{0}
                , @Description{0}
                , @Duration{0}
                , @Repeat{0}
                )", i));

            parameters.AddRange(new object[] {
                  "@AlarmId"                    +i, alarmId
              //, "@EventComponentId"
              //, "@UID" added for performance optimization purposes
                , "@Action"                     +i, alarm.Action.Action.Name                                                        // Alarm ACTION property
                , "@TriggerAbsoluteDateTimeUtc" +i, alarm.Trigger?.AbsoluteDateTimeUtc                                              // Alarm TRIGGER property
                , "@TriggerRelativeOffset"      +i, alarm.Trigger?.RelativeOffset?.Ticks                                            // Alarm TRIGGER property
                , "@TriggerRelatedStart"        +i, alarm.Trigger==null ? (bool?)null : alarm.Trigger.Related == RelatedType.Start  // Alarm trigger RELATED param
                , "@Summary"                    +i, alarm.Summary?.Text                                                             // Alarm SUMMARY property
                , "@Description"                +i, alarm.Description?.Text                                                         // Alarm DESCRIPTION property
                , "@Duration"                   +i, alarm.Duration?.Value?.Ticks                                                    // Alarm DURATION property
                , "@Repeat"                     +i, alarm.Repeat?.Value                                                             // Alarm REPEAT property
            });

            // Create SQL to save custom properties of this component of this component to [cal_CustomProperty] table.
            string customPropsSqlInsert;
            List<object> customPropsParamsInsert;
            if (PrepareSqlCustomPropertiesOfComponentAsync(alarm, alarmId, uid, out customPropsSqlInsert, out customPropsParamsInsert))
            {
                sql += "; " + customPropsSqlInsert;
                parameters.AddRange(customPropsParamsInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAttendeesAsync(DavContext context, IPropertyList<IAttendee> attendees, Guid eventComponentId, string uid)
    {
        string sql =
            @"INSERT INTO [cal_Attendee] (
                  [AttendeeId]
                , [EventComponentId]
                , [UID]
                , [Email]
                , [CommonName]
                , [DirectoryEntryRef]
                , [Language]
                , [UserType]
                , [SentBy]
                , [DelegatedFrom]
                , [DelegatedTo]
                , [Rsvp]
                , [ParticipationRole]
                , [ParticipationStatus]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
              "@EventComponentId", eventComponentId
            , "@UID", uid
        });

        int i = 0;
        foreach (IAttendee attendee in attendees)
        {
            valuesSql.Add(string.Format(@"(
                  @AttendeeId{0}
                , @EventComponentId
                , @UID
                , @Email{0}
                , @CommonName{0}
                , @DirectoryEntryRef{0}
                , @Language{0}
                , @UserType{0}
                , @SentBy{0}
                , @DelegatedFrom{0}
                , @DelegatedTo{0}
                , @Rsvp{0}
                , @ParticipationRole{0}
                , @ParticipationStatus{0}
            )", i));

            Guid attendeeId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@AttendeeId"         +i, attendeeId
              //, "@EventComponentId"
              //, "@UID" added for performance optimization purposes
                , "@Email"              +i, attendee.Uri?.Replace("mailto:", "")    // Attendee value
                , "@CommonName"         +i, attendee.CommonName                     // Attendee CN parameter
                , "@DirectoryEntryRef"  +i, attendee.Dir                            // Attendee DIR parameter
                , "@Language"           +i, attendee.Language                       // Attendee LANGUAGE parameter
                , "@UserType"           +i, attendee.UserType?.Name                 // Attendee CUTYPE parameter
                , "@SentBy"             +i, attendee.SentBy                         // Attendee SENT-BY parameter
                , "@DelegatedFrom"      +i, attendee.DelegatedFrom.FirstOrDefault() // Attendee DELEGATED-FROM parameter, here we assume only 1 delegator for the sake of simplicity
                , "@DelegatedTo"        +i, attendee.DelegatedTo.FirstOrDefault()   // Attendee DELEGATED-TO parameter, here we assume only 1 delegatee for the sake of simplicity
                , "@Rsvp"               +i, attendee.Rsvp == RsvpType.True          // Attendee RSVP parameter
                , "@ParticipationRole"  +i, attendee.ParticipationRole?.Name        // Attendee ROLE parameter
                , "@ParticipationStatus"+i, attendee.ParticipationStatus?.Name      // Attendee PARTSTAT parameter
            });

            // Prepare SQL to save custom property parameters to [cal_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("ATTENDEE", attendee.RawProperty, attendeeId, uid, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAttachmentsAsync(DavContext context, IPropertyList<IMedia> attachments, Guid eventComponentId, string uid)
    {
        // It is recommended to keep attchment size below 256Kb. In case files over 1Mb should 
        // be stored, use SQL FILESTREAM, FileTable or store content in file system.

        string sqlAttachment =
            @"INSERT INTO [cal_Attachment] (
                  [AttachmentId]
                , [EventComponentId]
                , [UID]
                , [MediaType]
                , [ExternalUrl]
                , [Content]
            ) VALUES (
                  @AttachmentId
                , @EventComponentId
                , @UID
                , @MediaType
                , @ExternalUrl
                , @Content
            )";

        string customPropertiesSql = "";
        List<object> customPropertiesParameters = new List<object>();

        foreach (IMedia attachment in attachments)
        {
            // To insert NULL to VARBINARY column SqlParameter must be passed with Size=-1 and Value=DBNull.Value.
            SqlParameter contentParam = new SqlParameter("@Content", SqlDbType.VarBinary, -1);
            contentParam.Value = DBNull.Value;

            if (!attachment.IsExternal)
            {
                byte[] content = Convert.FromBase64String(attachment.Base64Data);
                contentParam.Size = content.Length;
                contentParam.Value = content;
            }

            Guid attachmentId = Guid.NewGuid();

            await context.ExecuteNonQueryAsync(sqlAttachment,
                  "@AttachmentId"       , attachmentId
                , "@EventComponentId"   , eventComponentId
                , "@UID"                , uid
                , "@MediaType"          , attachment.MediaType
                , "@ExternalUrl"        , attachment.IsExternal ? attachment.Uri : null
                , contentParam
                );

            // Prepare SQL to save custom property parameters to [].
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("ATTACH", attachment.RawProperty, attachmentId, uid, out customPropSqlInsert, out customPropParametersInsert))
            {
                customPropertiesSql += "; " + customPropSqlInsert;
                customPropertiesParameters.AddRange(customPropParametersInsert);
            }
        }

        if (!string.IsNullOrEmpty(customPropertiesSql))
        {
            await context.ExecuteNonQueryAsync(customPropertiesSql, customPropertiesParameters.ToArray());
        }
    }

    private bool PrepareSqlParamsWriteCustomProperty(string propName, IRawProperty prop, Guid parentId, string uid, out string sql, out List<object> parameters)
    {
        sql =
            @"INSERT INTO [cal_CustomProperty] (
                  [ParentId]
                , [UID]
                , [PropertyName]
                , [ParameterName]
                , [Value]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        parameters = new List<object>();

        int origParamsCount = parameters.Count();

        bool isCustomProp = propName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase);

        string paramName = null;

        // Save custom prop value.
        if (isCustomProp)
        {
            string val = prop.RawValue;
            valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            )", paramIndex));

            parameters.AddRange(new object[] {
                              "@ParentId"     +paramIndex, parentId
                            , "@UID"          +paramIndex, uid       // added for performance optimization purposes
                            , "@PropertyName" +paramIndex, propName
                            , "@ParameterName"+paramIndex, paramName // null is inserted into the ParameterName field to mark prop value
                            , "@Value"        +paramIndex, val
                            });
            paramIndex++;
        }

        // Save parameters and their values.
        foreach (Parameter param in prop.Parameters)
        {
            paramName = param.Name;

            // For standard properties we save only custom params (that start with 'X-'). All standard patrams go to their fields in DB.
            // For custom properies we save all params.
            if (!isCustomProp && !paramName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase))
                continue;

            foreach (string value in param.Values)
            {
                string val = value;

                valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            )", paramIndex));

                parameters.AddRange(new object[] {
                              "@ParentId"     +paramIndex, parentId
                            , "@UID"          +paramIndex, uid       // added for performance optimization purposes
                            , "@PropertyName" +paramIndex, propName
                            , "@ParameterName"+paramIndex, paramName
                            , "@Value"        +paramIndex, val
                            });
                paramIndex++;
            }
        }

        if (origParamsCount < parameters.Count())
        {
            sql = string.Format(sql, string.Join(", ", valuesSql.ToArray()));
            return true;
        }
        return false;
    }

    private bool PrepareSqlCustomPropertiesOfComponentAsync(IComponent component, Guid parentId, string uid, out string sql, out List<object> parameters)
    {
        sql = "";
        parameters = new List<object>();

        // We save only single custom props here, multiple props are saved in other methods.
        string[] multiProps = new string[] { "ATTACH", "ATTENDEE", "EXDATE" };

        // Properties in IComponent.Properties are grouped by name.
        foreach (var pair in component.Properties)
        {
            if (multiProps.Contains(pair.Key.ToUpper()) || (pair.Value.Count != 1))
                continue;

            string sqlInsert;
            List<object> parametersInsert;
            if (PrepareSqlParamsWriteCustomProperty(pair.Key, pair.Value.First(), parentId, uid, out sqlInsert, out parametersInsert))
            {
                sql += "; " + sqlInsert;
                parameters.AddRange(parametersInsert);
            }
        }

        return !string.IsNullOrEmpty(sql);
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        ICalendar2 cal = await GetCalendarAsync();

        string sql = @"DELETE FROM [cal_CalendarFile] 
                       WHERE UID=@UID
                       AND [CalendarFolderId] IN (SELECT [CalendarFolderId] FROM [cal_Access] WHERE [UserId]=@UserId AND [Write]=1)";

        if(await Context.ExecuteNonQueryAsync(sql, 
              "@UID", uid
            , "@UserId", Context.UserId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }

        // Notify attendees that event is canceled if deletion is successful.
        cal.Method = cal.CreateMethodProp(MethodType.Cancel);
        await iMipEventSchedulingTransport.NotifyAttendeesAsync(Context, cal);
    }

    public async Task ReadAsync(Stream output, long startIndex, long count)
    {
        ICalendar2 cal = await GetCalendarAsync();
        new vFormatter().Serialize(output, cal);
    }
    
    private async Task<ICalendar2> GetCalendarAsync()
    {
        ICalendar2 cal = CalendarFactory.CreateCalendar2();
        cal.ProductId = cal.CreateTextProp("-//IT Hit//Collab Lib//EN");

        // Recurrent event or to-do can contain more than one VEVENT/VTODO component in one file.
        foreach (DataRow rowEventComponent in rowsEventComponents)
        {

            // add either event or to-do to the calendar
            bool isEvent = rowEventComponent.Field<bool>("ComponentType");
            IEventBase sc;
            if (isEvent)
            {
                sc = cal.Events.CreateComponent();
                cal.Events.Add(sc as IEvent);
            }
            else
            {
                sc = cal.ToDos.CreateComponent();
                cal.ToDos.Add(sc as IToDo);
            }

            // Read component properties from previously loaded [cal_EventComponent] rows.
            ReadEventComponent(sc, rowEventComponent, cal);


            Guid eventComponentId = rowEventComponent.Field<Guid>("EventComponentId");

            // Get [cal_RecurrenceException] rows that belong to this event component only and read recurrence exceptions dates.
            IEnumerable<DataRow> rowsThisScRecurrenceExceptions = rowsRecurrenceExceptions.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            ReadRecurrenceExceptions(sc.ExceptionDateTimes, rowsThisScRecurrenceExceptions, cal);

            // Get [cal_Alarm] rows that belong to this event component only and read alarms.
            IEnumerable<DataRow> rowsThisScAlarms = rowsAlarms.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            ReadAlarms(sc.Alarms, rowsThisScAlarms, cal);

            // Get [cal_Attendee] rows that belong to this event component only and read attendees.
            IEnumerable<DataRow> rowsThisScAttendees = rowsAttendees.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            ReadAttendees(sc.Attendees, rowsThisScAttendees, cal);

            // Get [cal_Attachment] rows that belong to this event component only.
            // Read attachments, load [cal_Attachment].[Content] if required.
            IEnumerable<DataRow> rowsThisScAttachments = rowsAttachments.Where(x => x.Field<Guid>("EventComponentId") == eventComponentId);
            await ReadAttachmentsAsync(Context, sc.Attachments, rowsThisScAttachments, cal);
        }

        // Generate VTIMEZONE components based on TZID parameters.
        cal.AutoGenerateTimeZones = true;

        return cal;
    }

    private void ReadEventComponent(IEventBase sc, DataRow row, ICalendar2 cal)
    {
        bool isAllDay = row.Field<bool?>("AllDay") == true;

        sc.Uid              = cal.CreateTextProp(row.Field<string>("UID"));                                     // UID property, iOS / OS X UID is case sensitive, Bynari WebDAV Collaborator UID is over 100 chars long
        sc.DateTimeStampUtc = cal.CreateDateProp(row.Field<DateTime?>("DateTimeStampUtc"), DateTimeKind.Utc);   // DTSTAMP property
        sc.CreatedUtc       = cal.CreateDateProp(row.Field<DateTime?>("CreatedUtc"), DateTimeKind.Utc);         // CREATED property
        sc.LastModifiedUtc  = cal.CreateDateProp(row.Field<DateTime?>("LastModifiedUtc"), DateTimeKind.Utc);    // LAST-MODIFIED property
        sc.Summary          = cal.CreateCalTextProp(row.Field<string>("Summary"));                              // SUMMARY property
        sc.Description      = cal.CreateCalTextProp(row.Field<string>("Description"));                          // DESCRIPTION property
        sc.Start            = cal.CreateCalDateProp(row.Field<DateTime?>("Start"), row.Field<string>("StartTimeZoneId"), isAllDay);                 // DTSTART property
        sc.Duration         = cal.CreateDurationProp(row.Field<long?>("Duration"));                             // DURATION property
        sc.Class            = cal.CreateClassProp(row.Field<string>("Class"));                                  // CLASS property
        sc.Location         = cal.CreateCalTextProp(row.Field<string>("Location"));                             // LOCATION property
        sc.Priority         = cal.CreateIntegerProp(row.Field<byte?>("Priority"));                              // PRIORITY property
        sc.Sequence         = cal.CreateIntegerProp(row.Field<int?>("Sequence"));                               // SEQ property
        sc.Status           = cal.CreateStatusProp(row.Field<string>("Status"));                                // STATUS property
        sc.Organizer        = cal.CreateCalAddressProp(EmailToUri(row.Field<string>("OrganizerEmail")), row.Field<string>("OrganizerCommonName"));  // ORGANIZER property

        // RECURRENCE-ID property
        sc.RecurrenceId     = cal.CreateRecurrenceIdProp(
            row.Field<DateTime?>("RecurrenceIdDate")                                                            // RECURRENCE-ID value
            , row.Field<string>("RecurrenceIdTimeZoneId")                                                       // RECURRENCE-ID TZID param
            , isAllDay                                                                                          // RECURRENCE-ID DATE or DATE-TIME
            , row.Field<bool?>("RecurrenceIdThisAndFuture")==true);                                             // RECURRENCE-ID RANGE param

        // CATEGORIES property list
        string categories = row.Field<string>("Categories") as string;
        if (!string.IsNullOrEmpty(categories))
        {
            string[] strCatProp = categories.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (string categoryList in strCatProp)
            {
                ICategories catProp = sc.Categories.CreateProperty();
                catProp.Categories = categoryList.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                sc.Categories.Add(catProp);
            }
        }

        // RRULE property
        string recurFrequency = row.Field<string>("RecurFrequency");
        if (!string.IsNullOrEmpty(recurFrequency))
        {
            sc.RecurrenceRule = cal.CreateProperty<IRecurrenceRule>();

            sc.RecurrenceRule.Frequency = ExtendibleEnum.FromString<FrequencyType>(recurFrequency);             // FREQ rule part
            sc.RecurrenceRule.Interval  = (uint?)row.Field<int?>("RecurInterval");                              // INTERVAL rule part
            sc.RecurrenceRule.Count     = (uint?)row.Field<int?>("RecurCount");                                 // COUNT rule part

            // WKST rule part
            string weekStart = row.Field<string>("RecurWeekStart");
            if (!string.IsNullOrEmpty(weekStart))
            {
                sc.RecurrenceRule.WeekStart = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), weekStart);
            }

            // UNTIL rule part
            DateTime? until = row.Field<DateTime?>("RecurUntil");
            if (until != null)
            {
                // UNTIL must be in UTC if DTSTART contains time zone or DTSTART is UTC.
                // UNTIL must be 'floating' if DTSTART is 'floating'.
                // UNTIL must be 'all day' if the DTSTART is 'all day'.
                // https://tools.ietf.org/html/rfc5545#section-3.3.10
                sc.RecurrenceRule.Until = new Date(
                    DateTime.SpecifyKind(until.Value,
                    sc.Start.Value.DateVal.Kind != DateTimeKind.Local /*floating*/ ? DateTimeKind.Utc : DateTimeKind.Local),
                    sc.Start.Value.Components);
            }

            // BYDAY rule part
            string byDay = row.Field<string>("RecurByDay");
            if (!string.IsNullOrEmpty(byDay))
            {
                sc.RecurrenceRule.ByDay = byDay.Split(',').Select(x => DayRule.Parse(x)).ToArray();
            }

            // BYMONTHDAY rule part
            string byMonthDay = row.Field<string>("RecurByMonthDay");
            if (!string.IsNullOrEmpty(byMonthDay))
            {
                sc.RecurrenceRule.ByMonthDay = byMonthDay.Split(',').Select(x => short.Parse(x)).ToArray();
            }

            // BYMONTH rule part
            string byMonth = row.Field<string>("RecurByMonth");
            if (!string.IsNullOrEmpty(byMonth))
            {
                sc.RecurrenceRule.ByMonth = byMonth.Split(',').Select(x => ushort.Parse(x)).ToArray();
            }

            // BYSETPOS  rule part
            string bySetPos = row.Field<string>("RecurBySetPos");
            if (!string.IsNullOrEmpty(bySetPos))
            {
                sc.RecurrenceRule.BySetPos = bySetPos.Split(',').Select(x => short.Parse(x)).ToArray();
            }      
        }

        if (sc is IEvent)
        {
            // Properties specific for events only
            IEvent vEvent = sc as IEvent;
            vEvent.End          = cal.CreateCalDateProp(row.Field<DateTime?>("End"), row.Field<string>("EndTimeZoneId"), isAllDay); // DTEND property
            vEvent.Transparency = cal.CreateTransparencyProp(row.Field<bool?>("EventTransparency"));                                // TRANSP property
        }
        else
        {
            // Properties specific for to-dos only
            IToDo vToDo = sc as IToDo;
            vToDo.Due           = cal.CreateCalDateProp(row.Field<DateTime?>("End"), row.Field<string>("EndTimeZoneId"), isAllDay); // DUE property
            vToDo.CompletedUtc  = cal.CreateDateProp(row.Field<DateTime?>("ToDoCompletedUtc"), DateTimeKind.Utc);                   // COMPLETED property
            vToDo.PercentComplete = cal.CreateIntegerProp(row.Field<byte?>("ToDoPercentComplete"));                                 // PERCENT-COMPLETE
        }

        // Get custom properties and custom parameters
        Guid eventComponentId = row.Field<Guid>("EventComponentId");
        IEnumerable<DataRow> rowsEventCustomProperties = rowsCustomProperties.Where(x => x.Field<Guid>("ParentId") == eventComponentId);
        ReadCustomProperties(sc, rowsEventCustomProperties);
    }

    private static void ReadRecurrenceExceptions(IPropertyList<ICalDateList> recurrenceExceptions, IEnumerable<DataRow> rowsRecurrenceExceptions, ICalendar2 cal)
    {
        foreach (DataRow rowRecurrenceException in rowsRecurrenceExceptions)
        {
            // EXDATE property
            ICalDateList exdate = cal.CreateCalDateListProp(
                new DateTime[] { rowRecurrenceException.Field<DateTime>("ExceptionDate") }                          // EXDATE value
                , rowRecurrenceException.Field<string>("TimeZoneId")                                                // EXDATE TZID param
                , rowRecurrenceException.Field<bool?>("AllDay") == true                                             // EXDATE DATE or DATE-TIME
                );
            recurrenceExceptions.Add(exdate);
        }
    }

    private void ReadAlarms(IComponentList<IAlarm> alarms, IEnumerable<DataRow> rowsAlarms, ICalendar2 cal)
    {
        foreach (DataRow rowAlarm in rowsAlarms)
        {
            IAlarm alarm = alarms.CreateComponent();                                            // VALARM component

            alarm.Action        = cal.CreateActionProp(rowAlarm.Field<string>("Action"));       // Alarm ACTION property
            alarm.Summary       = cal.CreateCalTextProp(rowAlarm.Field<string>("Summary"));     // Alarm SUMMARY property
            alarm.Description   = cal.CreateCalTextProp(rowAlarm.Field<string>("Description")); // Alarm DESCRIPTION property
            alarm.Duration      = cal.CreateDurationProp(rowAlarm.Field<long?>("Duration"));    // Alarm DURATION property
            alarm.Repeat        = cal.CreateIntegerProp(rowAlarm.Field<int?>("Repeat"));        // Alarm REPEAT property

            // Alarm TRIGGER property
            alarm.Trigger = cal.CreateProperty<ITrigger>();

            DateTime? absolute = rowAlarm.Field<DateTime?>("TriggerAbsoluteDateTimeUtc");
            if (absolute != null)
            {
                alarm.Trigger.AbsoluteDateTimeUtc = DateTime.SpecifyKind(absolute.Value, DateTimeKind.Utc);
            }

            long? offset = rowAlarm.Field<long?>("TriggerRelativeOffset");
            if (offset != null)
            {
                alarm.Trigger.RelativeOffset = new TimeSpan(offset.Value);
            }

            // Alarm trigger RELATED param
            bool? related = rowAlarm.Field<bool?>("TriggerRelatedStart");
            if (related != null)
            {
                alarm.Trigger.Related = related.Value ? RelatedType.Start : RelatedType.End;
            }

            // Get custom properties and custom parameters
            Guid alarmId = rowAlarm.Field<Guid>("AlarmId");
            IEnumerable<DataRow> rowsEventCustomProperties = rowsCustomProperties.Where(x => x.Field<Guid>("ParentId") == alarmId);
            ReadCustomProperties(alarm, rowsEventCustomProperties);

            alarms.Add(alarm);
        }
    }

    private void ReadAttendees(IPropertyList<IAttendee> attendees, IEnumerable<DataRow> rowsAttendees, ICalendar2 cal)
    {
        foreach (DataRow rowAttendee in rowsAttendees)
        {                
            IAttendee attendee = attendees.CreateProperty();                                                // ATTENDEE property

            attendee.Uri            = EmailToUri(rowAttendee.Field<string>("Email"));                       // Attendee value
            attendee.CommonName     = rowAttendee.Field<string>("CommonName");                              // Attendee CN parameter
            attendee.Dir            = rowAttendee.Field<string>("DirectoryEntryRef");                       // Attendee DIR parameter
            attendee.Language       = rowAttendee.Field<string>("Language");                                // Attendee LANGUAGE parameter
            attendee.UserType       = StringToEnum<CalendarUserType>(rowAttendee.Field<string>("UserType"));// Attendee CUTYPE parameter
            attendee.SentBy         = EmailToUri(rowAttendee.Field<string>("SentBy"));                      // Attendee SENT-BY parameter
            attendee.DelegatedFrom  = new[] { EmailToUri(rowAttendee.Field<string>("DelegatedFrom")) };     // Attendee DELEGATED-FROM parameter, here we assume only 1 delegator for the sake of simplicity
            attendee.DelegatedTo    = new[] { EmailToUri(rowAttendee.Field<string>("DelegatedTo")) };       // Attendee DELEGATED-TO parameter, here we assume only 1 delegatee for the sake of simplicity

            // Attendee RSVP parameter
            bool? rsvp = rowAttendee.Field<bool?>("Rsvp");
            if (rsvp != null)
            {
                attendee.Rsvp       = rsvp.Value ? RsvpType.True : RsvpType.False;
            }

            attendee.ParticipationRole   = StringToEnum<ParticipationRoleType>(rowAttendee.Field<string>("ParticipationRole"));     // Attendee ROLE parameter
            attendee.ParticipationStatus = StringToEnum<ParticipationStatusType>(rowAttendee.Field<string>("ParticipationStatus")); // Attendee PARTSTAT parameter

            AddParamValues(rowAttendee.Field<Guid>("AttendeeId"), attendee.RawProperty); // Add custom parameters from [cal_CustomProperty] table.

            attendees.Add(attendee);
        }
    }

    private async Task ReadAttachmentsAsync(DavContext context, IPropertyList<IMedia> attachments, IEnumerable<DataRow> rowsAttachments, ICalendar2 cal)
    {
        // Find if any attachments content should be read from datatbase.
        bool loadContent = rowsAttachments.Any(x => (x.Field<int>("ContentExists") == 1));

        if (loadContent)
        {
            // Reading attachments content from database.

            // Set timeout to maximum value to be able to download iCalendar files with large file attachments.
            System.Web.HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
            
            Guid eventComponentId = rowsAttachments.First().Field<Guid>("EventComponentId");
            string sql = "SELECT [AttachmentId], [MediaType], [ExternalUrl], [Content] FROM [cal_Attachment] WHERE [EventComponentId]=@EventComponentId";

            using (SqlDataReader reader = await context.ExecuteReaderAsync(CommandBehavior.SequentialAccess, sql, "@EventComponentId", eventComponentId))
            {
                while(await reader.ReadAsync())
                {
                    IMedia attachment = attachments.CreateProperty();                   // ATTACH property
                    Guid attachmentId = await reader.GetFieldValueAsync<Guid>(reader.GetOrdinal("AttachmentId"));

                    // Attachment FMTTYPE parameter
                    int ordMediaType = reader.GetOrdinal("MediaType");
                    if (!await reader.IsDBNullAsync(ordMediaType))
                    {
                        attachment.MediaType = await reader.GetFieldValueAsync<string>(ordMediaType);
                    }

                    // Attachment value as URL
                    int ordExternalUrl = reader.GetOrdinal("ExternalUrl");
                    if (!await reader.IsDBNullAsync(ordExternalUrl))
                    {
                        attachment.Uri = await reader.GetFieldValueAsync<string>(ordExternalUrl);
                    }
                                 
                    // Attachment value as inline content
                    int ordContent = reader.GetOrdinal("Content");
                    if (!await reader.IsDBNullAsync(ordContent))
                    {
                        using (Stream stream = reader.GetStream(ordContent))
                        {
                            using (MemoryStream memory = new MemoryStream())
                            {
                                await stream.CopyToAsync(memory);
                                attachment.Base64Data = Convert.ToBase64String(memory.ToArray());
                            }
                        }
                    }

                    AddParamValues(attachmentId, attachment.RawProperty); // Add custom parameters from [cal_CustomProperty] table.

                    attachments.Add(attachment);
                }
            }
        }
        else
        {
            // Attachments contain only URLs to external files.
            foreach (DataRow rowAttachment in rowsAttachments)
            {
                IMedia attachment = attachments.CreateProperty();                   // ATTACH property

                attachment.MediaType = rowAttachment.Field<string>("MediaType");    // Attachment FMTTYPE parameter
                attachment.Uri       = rowAttachment.Field<string>("ExternalUrl");  // Attachment value

                AddParamValues(rowAttachment.Field<Guid>("AttachmentId"), attachment.RawProperty); // Add custom parameters from [cal_CustomProperty] table.

                attachments.Add(attachment);
            }
        }
    }

    private static void ReadCustomProperties(IComponent component, IEnumerable<DataRow> rowsCustomProperies)
    {
        foreach (DataRow rowCustomProperty in rowsCustomProperies)
        {
            string propertyName = rowCustomProperty.Field<string>("PropertyName");

            IRawProperty prop;
            if (!component.Properties.ContainsKey(propertyName))
            {
                prop = component.CreateRawProperty();
                component.AddProperty(propertyName, prop);
            }
            else
            {
                prop = component.Properties[propertyName].FirstOrDefault();
            }

            string paramName = rowCustomProperty.Field<string>("ParameterName");
            string value = rowCustomProperty.Field<string>("Value");
            if (paramName == null)
            {
                // If ParameterName is null the Value contains property value
                prop.RawValue = value;
            }
            else
            {
                AddParamValue(prop, paramName, value);
            }
        }
    }

    private void AddParamValues(Guid propertyId, IRawProperty prop)
    {
        IEnumerable<DataRow> rowsCustomParams = rowsCustomProperties.Where(x => x.Field<Guid>("ParentId") == propertyId);
        foreach (DataRow rowCustomParam in rowsCustomParams)
        {
            string paramName = rowCustomParam.Field<string>("ParameterName");
            string paramValue = rowCustomParam.Field<string>("Value");
            AddParamValue(prop, paramName, paramValue);
        }
    }

    private static void AddParamValue(IRawProperty prop, string paramName, string paramValue)
    {
        // There could be parameters with identical name withing one property.

        // This call returns all values from all properties with specified name.
        IEnumerable<string> paramVals = prop.Parameters[paramName];

        // Add value.
        List<string> paramNewVals = paramVals.ToList();
        paramNewVals.Add(paramValue);

        // This call removes any parameters with identical names if any and 
        // replaces it with a single parameter with a lost of specified values.
        prop.Parameters[paramName] = paramNewVals;
    }

    private static string EmailToUri(string email)
    {
        if (email == null)
            return null;

        if (email.IndexOf('@') > 0)
            return string.Format("mailto:{0}", email);

        return email;
    }

    private static T StringToEnum<T>(string value) where T : ExtendibleEnum, new()
    {
        if (value == null)
            return null;

        T res;
        if (!ExtendibleEnum.TryFromString<T>(value, out res))
        {
            // If no matching value is found create new ExtendibleEnum or type T 
            // with specified string value and default numeric value (-1).
            res = new T();
            res.Name = value;
        }

        return res;
    }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.IFile">
            <summary>
            Represents a file in the WebDAV repository.
            </summary>
            <remarks>
            This interface represents a file in a repository. This is a marker interface derived from <see cref="T:ITHit.WebDAV.Server.IContent"/> 
            and <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/>, it does not add any additional properties or methods.    
            <see cref="P:ITHit.WebDAV.Server.IContent.ContentType"/> property must return the MIME type of the file.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.IContent">
            <summary>
            Base interface for items that have content, like <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/>.
            </summary>
            TODO: does this need to be a separate interface?
        </member>
        <member name="M:ITHit.WebDAV.Server.IContent.Read(System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Reads the file content from the repository and writes it to the specified stream.
            </summary>
            <param name="output">Output stream.</param>
            <param name="startIndex">The zero-bazed byte offset in file content at which to begin copying bytes to
            the output stream.</param>
            <param name="count">The number of bytes to be written to the output stream.</param>
            <returns> .</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            By default ASP.NET buffers content on server side before sending output. You must turn off buffering to
            eliminate keeping entire file content in memory before sending:
            <code>
            HttpContext.Current.Response.BufferOutput = false;
            </code>
            </para>
            <para>
            Client application can request only a part of a file specifying <b>Range</b> header. Download managers 
            may use this header to download single file using several threads at a time.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IContent.Read&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.IContent.Write(System.IO.Stream,System.String,System.Int64,System.Int64)">
            <summary>
            Saves the content of the file from the specified stream to the WebDAV repository.
            </summary>
            <param name="content">Stream to read the content of the file from.</param>
            <param name="contentType">Indicates the media type of the file.</param>
            <param name="startIndex">Start offset to which content shall be saved.</param>
            <param name="totalFileSize">Entire length of the file. Is is not less then length of
            <paramref name="content"/> stream.</param>
            <returns>Boolean value indicating whether entire stream was written. This value is used by engine to take
            decision whether autocheckin shall be performed.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">The file was locked and client did not provide lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>IIS and ASP.NET does not support files upload larger than 2Gb. If you need to upload files larger
            than 2Gb you must develop HttpListener-based WebDAV server or implement resumable upload interfaces.</para>
            <para>
            If you are creating HttpHandler-based WebDAV server you must specify the file 
            maximum upload size in web.config of your web application. By default maximum 
            upload size is set to 4096 KB (4 MB) by ASP.NET. This limit is used to 
            prevent denial of service attacks caused by users posting large files to the 
            server. To increase the upload limit add &lt;httpRuntime&gt; section to your web application web.config
            file and specify the limit in kilobytes: 
            </para>
            <code>
              <![CDATA[
                <configuration>
                   <system.web>
                      ...
                      <httpRuntime maxRequestLength="2097151" /> //2Gb
                      ...
                   </system.web>
                </configuration>
            ]]>
            </code>
            <para>
            When client uploads file to IIS, ASP.NET first creates the file in a the temporary upload directory.
            Only when the entire file is uploaded to server you can read its content from stream. By default ASP.NET
            uploads files to <b>%FrameworkInstallLocation%\Temporary ASP.NET Files</b> folder.
            You must make sure you have enough disk space to keep temporary files uploaded to your server.
            To change this folder location add the following section to your web.config file:
            <code>
              <![CDATA[
               <configuration>
                   <system.web>
                      ...
                      <compilation tempDirectory="temporary files directory" />
                      ...
                   </system.web>
               </configuration>
              ]]>
            </code>
            To avoid temporary file creation and pass content directly to engine set the
            <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/>
            module in your web.config file. Unlike IIS/ASP.NET, HttpListener-based server does not create any
            temporary files when handling uploads.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IContent.Write&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IContent.ContentType">
            <summary>
            Gets the media type of the file.
            </summary>
            <remarks>
            <para>
            The mime-type provided by this property is returned in a Content-Type header with GET request.
            </para>
            <para>
            When deciding which action to perform when downloading a file some WebDAV clients and browsers 
            (such as Internet Explorer) rely on file extension, while others (such as Firefox) rely on Content-Type
            header returned by server. For identical behavior in all browsers and WebDAV clients your server must
            return a correct mime-type with a requested file.
            </para>
            </remarks>
            <value>The MIME type of the file.</value>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IContent.ContentType&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IContent.ContentLength">
            <summary>
            Gets the size of the file content in bytes.
            </summary>
            <value>Length of the file content in bytes.</value>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IContent.ContentLength&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.IContent.Etag">
            <summary>
            Gets entity tag - string that identifies current state of resource's content.
            </summary>
            <remarks>
            More information about etags is available here: http://en.wikipedia.org/wiki/HTTP_ETag
            You can return here either cheksum or hash or counter which increases with every
            modification.
            This property shall return different value if content changes.
            Return <c>null</c> to indicate that server doesn't support etags.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IContent.Etag&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.IScheduleOutboxFolder">
            <summary>
            Represents scheduling outbox folder.
            </summary>
            <remarks>
            <para>
            This is the marker interface, it does not add any new methods in addition 
            to provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFolder"/> and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarItem"/> interfaces. Items that impement this interface report 
            "calendar-auto-schedule" support in response to the OPTIONS request.
            </para>
            <para>
            This type of folders are used as the target for busy time information requests, and to 
            manage privileges that apply to outgoing scheduling requests.
            </para>
            <para>
            Scheduling outbox folder can not contain any other folders. Folders of this type 
            should not be nested under  and <see cref="T:ITHit.WebDAV.Server.CalDav.ICalendarFolder"/> items at any depth.
            </para>
            <para>More details culd be found at http://tools.ietf.org/html/rfc6638#section-2.1</para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInvite">
            <summary>
            Represents information about invitation.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Address">
            <summary>
            Principal-URL for a sharee hosted on the same server, a calendar user address or email address.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.CommonName">
            <summary>
            Name of the person to share calendar with.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Status">
            <summary>
            Sharing invite status.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Access">
            <summary>
            Shared calendar access level privilege.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.CalDav.SharingInvite.Summary">
            <summary>
            Summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.SharingInviteStatus">
            <summary>
            Sharing invite status.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Noresponse">
            <summary>
            Indicates that the sharee has never replied to the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Accepted">
            <summary>
            Indicates that the sharee has accepted the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Declined">
            <summary>
            Indicates that the sharee has declined the corresponding sharing invite.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.CalDav.SharingInviteStatus.Invalid">
            <summary>
            Indicates that the corresponding sharee is not a valid calendar user known to the server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookDiscovery">
            <summary>
            Assists in finding address books on a CardDAV server. Enables <b>addressbook-home-set</b> feature support discovery.
            </summary>
            <remarks>
            <para>
            This interface helps finding folders that contain address books. You will implement this interface on principal items, 
            as well as on any other items that you wish to report <b>addressbook-home-set</b> feature support and list folders that 
            contain address books owned by currently logged-in user. 
            </para>
            <para>
            This interface provides <see cref="M:ITHit.WebDAV.Server.CardDav.IAddressbookDiscovery.GetAddressbookHomeSet"/>) method that is called by the Engine 
            when client is discovering list of folders that contain address books.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class Discovery : IAddressbookDiscoveryAsync
{
    protected DavContext Context;

    public Discovery(DavContext context)
    {
        this.Context = context;
    }

    public async Task<IEnumerable<IItemCollectionAsync>> GetAddressbookHomeSetAsync()
    {
        return new[] { new AddressbooksRootFolder(Context) };
    }

    public bool AddressbookHomeSetEnabled
    {
        get
        {
            return true;
        }
    }
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class AddressbooksRootFolder : LogicalFolder, IFolderAsync
{
    private static readonly string addressbooksRootFolderName = "addressbooks";

    public static string AddressbooksRootFolderPath = DavLocationFolder.DavLocationFolderPath + addressbooksRootFolderName + '/';

    public AddressbooksRootFolder(DavContext context)
        : base(context, AddressbooksRootFolderPath)
    {
    }

    public override async Task<IEnumerable<IHierarchyItemAsync>> GetChildrenAsync(IList<PropertyName> propNames)
    {
        // Here we list addressbooks from back-end storage. 
        // You can filter addressbooks if requied and return only addressbooks that user has access to.
        return (await AddressbookFolder.LoadAllAsync(Context)).OrderBy(x => x.Name);
    }

    public Task<IFileAsync> CreateFileAsync(string name)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task CreateFolderAsync(string name)
    {
        await AddressbookFolder.CreateAddressbookFolderAsync(Context, name, "");
    }
}
]]></code>
    </example>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class AddressbookFolder : DavHierarchyItem, IAddressbookFolderAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<IAddressbookFolderAsync> LoadByIdAsync(DavContext context, Guid addressbookFolderId)
    {
        // Load only address book that the use has access to. 
        // Also load complete ACL for this address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access]
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@AddressbookFolderId", addressbookFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only address books that the use has access to. 
        // Also load complete ACL for each address book, but only if user has access to that address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<IAddressbookFolderAsync> addressbookFolders = new List<IAddressbookFolderAsync>();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))
        {
            DataTable addressbooks = new DataTable();
            addressbooks.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowAddressbookFolder in addressbooks.Rows)
            {
                Guid addressbookFolderId = rowAddressbookFolder.Field<Guid>("AddressbookFolderId");

                string filter = string.Format("AddressbookFolderId = '{0}'", addressbookFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                addressbookFolders.Add(new AddressbookFolder(context, addressbookFolderId, rowAddressbookFolder, rowsAccess));
            }
        }

        return addressbookFolders;
    }

    internal static async Task CreateAddressbookFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create address book.
        // 2. Grant owner privileges to the user on the created address book(s).
        string sql = @"INSERT INTO [card_AddressbookFolder] (
                      [AddressbookFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @AddressbookFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [card_Access] (
                      [AddressbookFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @AddressbookFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid addressbookFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@AddressbookFolderId", addressbookFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid addressbookFolderId;

    private readonly DataRow rowAddressbookFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowAddressbookFolder != null ? rowAddressbookFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId);
        }
    }

    private AddressbookFolder(DavContext context, Guid addressbookFolderId, DataRow addressbook, DataRow[] rowsAccess)
        : base(context)
    {
        this.addressbookFolderId    = addressbookFolderId;
        this.rowAddressbookFolder   = addressbook;
        this.rowsAccess             = rowsAccess;
    }

    public async Task<IEnumerable<ICardFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of file names from path list.
        IEnumerable<string> fileNames = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CardFile.LoadByFileNamesAsync(Context, fileNames, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICardFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList())).Cast<ICardFileAsync>();
    }

    public string AddressbookDescription 
    {
        get { return rowAddressbookFolder.Field<string>("Description"); }
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetChildrenAsync(IList<PropertyName> propNames)
    {
        // Here we enumerate all business cards contained in this address book.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync() method call, that follows this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return await CardFile.LoadByAddressbookFolderIdAsync(Context, addressbookFolderId, PropsToLoad.Minimum);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual business card file is created in datatbase in CardFile.Write call.
        string fileName = System.IO.Path.GetFileNameWithoutExtension(name);
        return CardFile.CreateCardFile(Context, addressbookFolderId, fileName);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only addressbooks renaming. Check that user has permissions to write.
        string sql = @"UPDATE [card_AddressbookFolder] SET Name=@Name 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql, 
              "@Name"               , destName
            , "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete address book and all vCards associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [card_AddressbookFolder] 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [card_AddressbookFolderProperty] WHERE [AddressbookFolderId] = @AddressbookFolderId",
                "@AddressbookFolderId", addressbookFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();
        
        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))
        {
            while (reader.Read())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [card_AddressbookFolderProperty]
              WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , prop.QualifiedName.Name,
            "@Namespace"            , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [card_AddressbookFolderProperty] ([AddressbookFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@AddressbookFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [card_AddressbookFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [card_AddressbookFolderProperty]
                          WHERE [AddressbookFolderId] = @AddressbookFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , name,
            "@Namespace"            , ns);
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId")== Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem">
            <summary>
            Represents folder, file or principal on a CardDAV server. Enables <b>addressbook</b> feature support discovery.
            </summary>
            <remarks>
            <para>This is the marker interface, it does not provide any methods or properties.</para>
            <para>
            Items that implement this interface report CardDAV support in OPTIONS requests. 
            If this intervace is found on an item, the <b>DAV</b> header will include <b>addressbook</b> token.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookDiscovery.GetAddressbookHomeSet">
            <summary>
            Returns list of folder items that contain address books owned by this principal.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            Note that this property returns list of folders that contain address book folders, NOT the address book folders themselves.
            </para>
            <para>
            http://tools.ietf.org/html/rfc6352#section-7.1.1
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.CardDav.IAddressbookDiscovery.AddressbookHomeSetEnabled">
            <summary>
            Returns <b>true</b> if <b>addressbook-home-set</b> feature is enabled, <b>false</b> otherwise.
            </summary>
            <remarks>
            <para>
            In this method you can analyze User-Agent header to find out the client application used for accessing the server
            and enable/disable <b>addressbook-home-set</b> feature for specific client. 
            </para>
            <para>
            iOS and OS X does require <b>addressbook-home-set</b> feature to be always enabled. On the other hand it may consume extra 
            resources especially with iOS CardDAV client. iOS starts immediate synchronization of all address books found on the server 
            via home-set request. Typically you will always enable heome-set for iOS and OS X CardDAV clients, but may disable it for other clients.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookReport">
            <summary>
            Represents an item that can process <b>addressbook-query</b> and <b>addressbook-multiget</b> reports.
            </summary>
            <remarks>
            <para>
            Items that implement this interface advertise support for <b>addressbook-query</b> and <b>addressbook-multiget</b> 
            reports. 
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookReport.MultiGet(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of business card files that correspont to the specified list of item paths.
            </summary>
            <remarks>
            <para>
            This method is called by the Engine during <b>addressbook-multiget</b> call.
            </para>
            <para>
            For each item from the <b>pathList</b> parameter return an item that corresponds to path or <b>null</b> if the item is not found.
            </para>
            </remarks>
            <param name="pathList">Business card files path list.</param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of business card files. Returns <b>null</b> for any item that is not found.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.CardDav.IAddressbookReport.Query(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of business card files that match specified filter. 
            </summary>
            <remarks>
            <para>
            This method is called by the Engine during <b>addressbook-query</b> call.
            </para>
            </remarks>
            <param name="rawQuery">
            Raw query sent by the client.
            </param>
            <param name="propNames">
            Properties requested by the client. You can use this as a hint about what properties will be called by 
            the Engine for each item that are returned from this method.
            </param>
            <returns>List of  business card files. Returns <b>null</b> for any item that is not found.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavEnvironment">
            <summary>
            Exposes environment specific information like the .net runtime running.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavEnvironment._isRnningOnMono">
            <summary>
            Indicating whether the current .net runtime is mono or not.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEnvironment.#cctor">
            <summary>
            Initializes the <see cref="T:ITHit.WebDAV.Server.DavEnvironment"/> class.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEnvironment.IsRunningOnMono">
            <summary>
            Gets a value indicating whether the current .net runtime is mono or not.
            </summary>
            <returns><code>True</code> if the current runtime is mono otherwise <code>false</code>.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.ICardFile">
            <summary>
            Represents business card in address book on a CardDAV server.
            </summary>
            <remarks>
            <para>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/> and <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem"/> interfaces.  
            Items of this type will return content returned from 
            <see cref="M:ITHit.WebDAV.Server.IContent.Read(System.IO.Stream,System.Int64,System.Int64)"/> method in <b>address-data</b> 
            CardDAV property.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class CardFile : DavHierarchyItem, ICardFileAsync
{
    public static string Extension = ".vcf";

    public static async Task<IEnumerable<ICardFileAsync>> LoadByAddressbookFolderIdAsync(DavContext context, Guid addressbookFolderId, PropsToLoad propsToLoad)
    {
        // propsToLoad == PropsToLoad.Minimum -> Typical GetChildren call by iOS, Android, eM Client, etc CardDAV clients
        // [Summary] is typically not required in GetChildren call, 
        // they are extracted for demo purposes only, to be displayed in Ajax File Browser.

        // propsToLoad == PropsToLoad.All -> Bynari call, it requires all props in GetChildren call.

        if (propsToLoad != PropsToLoad.Minimum)
            throw new NotImplementedException("LoadByAddressbookFolderIdAsync is implemented only with PropsToLoad.Minimum.");

        string sql = @"SELECT * FROM [card_CardFile] 
                       WHERE [AddressbookFolderId] = @AddressbookFolderId
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        //sql = string.Format(sql, GetScPropsToLoad(propsToLoad));
        
        return await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@AddressbookFolderId", addressbookFolderId);
    }

    public static async Task<IEnumerable<ICardFileAsync>> LoadByFileNamesAsync(DavContext context, IEnumerable<string> fileNames, PropsToLoad propsToLoad)
    {
        // Get IN clause part with list of file UIDs for SELECT.
        string selectIn = string.Join(", ", fileNames.Select(a => string.Format("'{0}'", a)).ToArray());

        string sql = @"SELECT * FROM [card_CardFile] 
                       WHERE [FileName] IN ({0})
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        if(propsToLoad==PropsToLoad.All)
        {
            sql += @";SELECT * FROM [card_Email]             WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Address]           WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_InstantMessenger]  WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Telephone]         WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_Url]               WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0}))
                     ;SELECT * FROM [card_CustomProperty]    WHERE [UID] IN (SELECT UID FROM [card_CardFile] WHERE [FileName] IN ({0})) AND [ClientAppName] = @ClientAppName";
        }

        sql = string.Format(sql, selectIn);

        return await LoadAsync(context, sql,
              "@UserId", context.UserId
            , "@ClientAppName", AppleCardInteroperability.GetClientAppName(context.Request.UserAgent));
    }

    private static async Task<IEnumerable<ICardFileAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<ICardFileAsync> items = new List<ICardFileAsync>();

        Stopwatch stopWatch = Stopwatch.StartNew();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))
        {
            DataTable cards = new DataTable();
            cards.Load(reader);

            DataTable emails = new DataTable();
            if (!reader.IsClosed)
                emails.Load(reader);

            DataTable addresses = new DataTable();
            if (!reader.IsClosed)
                addresses.Load(reader);

            DataTable instantMessengers = new DataTable();
            if (!reader.IsClosed)
                instantMessengers.Load(reader);

            DataTable telephones = new DataTable();
            if (!reader.IsClosed)
                telephones.Load(reader);

            DataTable urls = new DataTable();
            if (!reader.IsClosed)
                urls.Load(reader);

            DataTable cardCustomProperties = new DataTable();
            if (!reader.IsClosed)
                cardCustomProperties.Load(reader);

            stopWatch.Stop();
            context.Engine.Logger.LogDebug(string.Format("SQL took: {0}ms", stopWatch.ElapsedMilliseconds));


            foreach (DataRow rowCardFile in cards.Rows)
            {
                DataRow[] rowsEmails                = new DataRow[0];
                DataRow[] rowsAddresses             = new DataRow[0];
                DataRow[] rowsInstantMessengers     = new DataRow[0];
                DataRow[] rowsTelephones            = new DataRow[0];
                DataRow[] rowsUrls                  = new DataRow[0];
                DataRow[] rowsCustomProperties      = new DataRow[0];

                string uid = rowCardFile.Field<string>("UID");

                if (emails.Columns["UID"] != null)
                {
                    string filter = string.Format("UID = '{0}'", uid);

                    rowsEmails              = emails.Select(filter);
                    rowsAddresses           = addresses.Select(filter);
                    rowsInstantMessengers   = instantMessengers.Select(filter);
                    rowsTelephones          = telephones.Select(filter);
                    rowsUrls                = urls.Select(filter);
                    rowsCustomProperties = cardCustomProperties.Select(filter);
                }

                string fileName = rowCardFile.Field<string>("FileName");

                items.Add(new CardFile(context, fileName, rowCardFile, rowsEmails, rowsAddresses, rowsInstantMessengers, rowsTelephones, rowsUrls, rowsCustomProperties));
            }
        }

        return items;
    }

    public static CardFile CreateCardFile(DavContext context, Guid addressbookFolderId, string fileName)
    {
        CardFile cardFile = new CardFile(context, fileName, null, null, null, null, null, null, null);
        cardFile.addressbookFolderId = addressbookFolderId;
        return cardFile;
    }

    private readonly string fileName = null;

    private readonly DataRow rowCardFile = null;

    private readonly DataRow[] rowsEmails = null;

    private readonly DataRow[] rowsAddresses = null;

    private readonly DataRow[] rowsInstantMessengers = null;

    private readonly DataRow[] rowsTelephones = null;

    private readonly DataRow[] rowsUrls = null;

    private readonly DataRow[] rowsCustomProperties = null;

    private bool isNew
    {
        get { return addressbookFolderId != Guid.Empty; }
    }

    private int paramIndex = 0;

    private Guid addressbookFolderId = Guid.Empty;

    public override string Name
    {
        get
        {
            return rowCardFile.Field<string>("FormattedName");
        }
    }

    public override string Path
    {
        get
        {
            Guid addressbookFolderId = rowCardFile.Field<Guid>("AddressbookFolderId");
            string fileName = rowCardFile.Field<string>("FileName");
            return string.Format("{0}{1}/{2}{3}", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId, fileName, Extension);
        }
    }

    public string Etag
    {
        get
        {
            byte[] bETag = rowCardFile.Field<byte[]>("ETag");
            return BitConverter.ToUInt64(bETag.Reverse().ToArray(), 0).ToString(); // convert timestamp value to number
        }
    }

    public override DateTime Created
    {
        get { return rowCardFile.Field<DateTime>("CreatedUtc"); }
    }

    public override DateTime Modified
    {
        get { return rowCardFile.Field<DateTime>("ModifiedUtc"); }
    }

    public long ContentLength
    {
        get { return -1; }
    }

    public string ContentType
    {
     get { return "text/vcard"; }
    }

    private CardFile(DavContext context, string fileName,
        DataRow rowCardFile, DataRow[] rowsEmails, DataRow[] rowsAddresses, DataRow[] rowsInstantMessengers,
        DataRow[] rowsTelephones, DataRow[] rowsUrls, DataRow[] rowsCustomProperties)
        : base(context)
    {
        this.fileName               = fileName;
        this.rowCardFile            = rowCardFile;
        this.rowsEmails             = rowsEmails;
        this.rowsAddresses          = rowsAddresses;
        this.rowsInstantMessengers  = rowsInstantMessengers;
        this.rowsTelephones         = rowsTelephones;
        this.rowsUrls               = rowsUrls;
        this.rowsCustomProperties   = rowsCustomProperties;
    }

    public async Task<bool> WriteAsync(Stream stream, string contentType, long startIndex, long totalFileSize)
    {
        //Set timeout to maximum value to be able to upload large card files.
        System.Web.HttpContext.Current.Server.ScriptTimeout = int.MaxValue;
        string vCard;
        using (StreamReader reader = new StreamReader(stream))
        {
            vCard = reader.ReadToEnd();
        }

        // Typically the stream contains a single vCard.
        IEnumerable<IComponent> cards = new vFormatter().Deserialize(vCard);
        ICard2 card = cards.First() as ICard2;

        // Card file UID which is equal to file name.
        string uid = card.Uid.Text;

        // Check if this CardDAV client application requires properties conversion.
        if (AppleCardInteroperability.NeedsConversion(Context.Request.UserAgent))
        {
            AppleCardInteroperability.Normalize(card);
        }

        // The client app name is stored in DB to update and extract only custom props created by the client making a request.
        string clientAppName = AppleCardInteroperability.GetClientAppName(Context.Request.UserAgent);

        // Save data to [card_CardFile] table.
        await WriteCardFileAsync(Context, card, addressbookFolderId, isNew, clientAppName);

        // Save emails.
        await WriteEmailsAsync(Context, card.Emails, uid, clientAppName);

        // Save addresses.
        await WriteAddressesAsync(Context, card.Addresses, uid, clientAppName);

        // Save telephones.
        await WriteTelephonesAsync(Context, card.Telephones, uid, clientAppName);

        // Save URLs
        await WriteUrlsAsync(Context, card.Urls, uid, clientAppName);

        // Save instant messengers. vCard 3.0+ only
        ICard3 card3 = card as ICard3;
        if (card3 != null)
        {
            await WriteInstantMessengersAsync(Context, card3.InstantMessengers, uid, clientAppName);
        }

        return true;
    }

    private async Task WriteCardFileAsync(DavContext context, ICard2 card, Guid addressbookFolderId, bool isNew, string clientAppName)
    {
        string sql;
        if (isNew)
        {
            sql =
                @"IF EXISTS (SELECT 1 FROM [card_Access] WHERE [AddressbookFolderId]=@AddressbookFolderId AND [UserId]=@UserId AND [Write]=1)
                  INSERT INTO [card_CardFile] (
                      [UID]
                    , [AddressbookFolderId]
                 , [FileName]
                 , [Version]
                 , [Product]
                 , [FormattedName]
                 , [FamilyName]
                 , [GivenName]
                 , [AdditionalNames]
                 , [HonorificPrefix]
                 , [HonorificSuffix]
                 , [Kind]
                 , [Nickname]
                 , [Photo]
                 , [PhotoMediaType]
                 , [Logo]
                 , [LogoMediaType]
                 , [Sound]
                 , [SoundMediaType]
                 , [Birthday]
                 , [Anniversary]
                 , [Gender]
                 , [RevisionUtc]
                 , [SortString]
                 , [Language]
                 , [TimeZone]
                 , [Geo]
                 , [Title]
                 , [Role]
                 , [OrgName]
                 , [OrgUnit]
                 , [Categories]
                 , [Note]
                 , [Classification]
                ) VALUES (
                      @UID
                    , @AddressbookFolderId
                    , @FileName
                    , @Version
                    , @Product
                 , @FormattedName
                 , @FamilyName
                 , @GivenName
                 , @AdditionalNames
                 , @HonorificPrefix
                 , @HonorificSuffix
                 , @Kind
                 , @Nickname
                 , @Photo
                 , @PhotoMediaType
                 , @Logo
                 , @LogoMediaType
                 , @Sound
                 , @SoundMediaType
                 , @Birthday
                 , @Anniversary
                 , @Gender
                 , @RevisionUtc
                 , @SortString
                 , @Language
                 , @TimeZone
                 , @Geo
                 , @Title
                 , @Role
                 , @OrgName
                 , @OrgUnit
                 , @Categories
                 , @Note
                 , @Classification
                )";
        }
        else
        {
            // We can only update record in [card_CardFile] table.
            // There is no way to update [card_Email], [card_Address], [card_InstantMessenger], [card_Telephone] and [card_Url]
            // tables for existing card, we must delete all records for this UID and recreate.

            // We can keep custom props in [card_CustomProperty] table if they were created by a different CardDAV client.

            // [ModifiedUtc] field update triggers [ETag] field update which is used for synchronyzation.
            sql =
                @"IF EXISTS (SELECT 1 FROM [card_CardFile] 
                       WHERE FileName=@FileName
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1))
                  BEGIN
                      UPDATE [card_CardFile] SET 
                          [ModifiedUtc]     = @ModifiedUtc
                     , [Version]         = @Version
                     , [Product]         = @Product
                     , [FormattedName]   = @FormattedName
                     , [FamilyName]      = @FamilyName
                     , [GivenName]       = @GivenName
                     , [AdditionalNames] = @AdditionalNames
                     , [HonorificPrefix] = @HonorificPrefix
                     , [HonorificSuffix] = @HonorificSuffix
                     , [Kind]            = @Kind
                     , [Nickname]        = @Nickname
                     , [Photo]           = @Photo
                     , [PhotoMediaType]  = @PhotoMediaType
                     , [Logo]            = @Logo
                     , [LogoMediaType]   = @LogoMediaType
                     , [Sound]           = @Sound
                     , [SoundMediaType]  = @SoundMediaType
                     , [Birthday]        = @Birthday
                     , [Anniversary]     = @Anniversary
                     , [Gender]          = @Gender
                     , [RevisionUtc]     = @RevisionUtc
                     , [SortString]      = @SortString
                     , [Language]        = @Language
                     , [TimeZone]        = @TimeZone
                     , [Geo]             = @Geo
                     , [Title]           = @Title
                     , [Role]            = @Role
                     , [OrgName]         = @OrgName
                     , [OrgUnit]         = @OrgUnit
                     , [Categories]      = @Categories
                     , [Note]            = @Note
                     , [Classification]  = @Classification
                      WHERE 
                        [UID] = @UID
                
                      ; DELETE FROM [card_Email]              WHERE [UID] = @UID
                      ; DELETE FROM [card_Address]            WHERE [UID] = @UID
                      ; DELETE FROM [card_InstantMessenger]   WHERE [UID] = @UID
                      ; DELETE FROM [card_Telephone]          WHERE [UID] = @UID
                      ; DELETE FROM [card_Url]                WHERE [UID] = @UID
                      ; DELETE FROM [card_CustomProperty]     WHERE [UID] = @UID AND (([ClientAppName] = @ClientAppName) OR ([ParentId] != [UID]) OR ([ClientAppName] IS NULL))
                  END";

        }
        // [ClientAppName] = @ClientAppName -> delete all custom props created by this client.
        // [ParentId] != [UID]              -> delete all custom params from multiple props: EMAIL, ADR, TEL, IMPP. Keep custom params for any single props in [card_Card].
        // [ClientAppName] IS NULL          -> delete all custom props created by some unknown CardDAV client.

        string uid = card.Uid.Text;
                                                                                                    
        if (await context.ExecuteNonQueryAsync(sql,
              "@UID"            , uid                                                                   // UID
            , "UserId"          , context.UserId
            , "@AddressbookFolderId", addressbookFolderId                                               // used only when inserting
            , "@FileName"       , fileName                                                              // In case of CardDAV a file name is sypically a GUID, but it is different from UID.
            , "@ModifiedUtc"    , DateTime.UtcNow
            , "@Version"        , card.Version.Text                                                     // VERSION
            , "@Product"        , card.ProductId?.Text                                                  // PRODID
            , "@FormattedName"  , card.FormattedNames.PreferedOrFirstProperty.Text                      // FN                           Here we assume only 1 prop for the sake of simplicity.
            , "@FamilyName"     , card.Name.FamilyName                                                  // N
            , "@GivenName"      , card.Name.GivenName                                                   // N
            , "@AdditionalNames", card.Name.AdditionalNamesList                                         // N
            , "@HonorificPrefix", card.Name.HonorificPrefix                                             // N
            , "@HonorificSuffix", card.Name.HonorificSuffix                                             // N
            , "@Kind"           , (card as ICard4)?.Kind?.Text                                          // KIND         (vCard 4.0)
            , "@Nickname"       , (card as ICard3)?.NickNames.PreferedOrFirstProperty?.Values.First()   // NICKNAME     (vCard 3.0+)    Here we assume only 1 prop with 1 value for the sake of simplicity.
            , CreateVarBinaryParam("@Photo", card.Photos.PreferedOrFirstProperty?.Base64Data)           // PHOTO                        Here we assume only 1 prop for the sake of simplicity.
            , "@PhotoMediaType" , card.Photos.PreferedOrFirstProperty?.MediaType                        // PHOTO TYPE param
            , CreateVarBinaryParam("@Logo",  card.Logos.PreferedOrFirstProperty?.Base64Data)            // LOGO                         Here we assume only 1 prop for the sake of simplicity.
            , "@LogoMediaType"  , card.Logos.PreferedOrFirstProperty?.MediaType                         // LOGO  TYPE param
            , CreateVarBinaryParam("@Sound", card.Sounds.PreferedOrFirstProperty?.Base64Data)           // SOUND                        Here we assume only 1 prop for the sake of simplicity.
            , "@SoundMediaType" , card.Sounds.PreferedOrFirstProperty?.MediaType                        // SOUND TYPE param
            , new SqlParameter("@Birthday"   , card.BirthDate?.Value?.DateVal ?? DBNull.Value as object)                { SqlDbType = SqlDbType.DateTime2 }   // BDAY
            , new SqlParameter("@Anniversary", (card as ICard4)?.Anniversary?.Value?.DateVal ?? DBNull.Value as object) { SqlDbType = SqlDbType.DateTime2 }   // ANNIVERSARY  (vCard 4.0)
            , "@Gender"         , (card as ICard4)?.Gender?.Sex                                         // GENDER       (vCard 4.0)
            , "@RevisionUtc"    , card.Revision?.Value.DateVal                                          // REV
            , "@SortString"     , card.SortString?.Text                                                 // SORT-STRING
            , "@Language"       , (card as ICard4)?.ContactLanguages.PreferedOrFirstProperty.Text       // LANG         (vCard 4.0)     Here we assume only 1 prop for the sake of simplicity.
            , "@TimeZone"       , card.TimeZones.PreferedOrFirstProperty?.Text                          // TZ
            , "@Geo"            , null                                                                  // GEO
            , "@Title"          , card.Titles.PreferedOrFirstProperty?.Text                             // TITLE
            , "@Role"           , card.Roles.PreferedOrFirstProperty?.Text                              // ROLE
            , "@OrgName"        , card.Organizations.PreferedOrFirstProperty?.Name                      // ORG                          Here we assume only 1 prop for the sake of simplicity.
            , "@OrgUnit"        , card.Organizations.PreferedOrFirstProperty?.Units?.First()            // ORG                          Here we assume only 1 prop with 1 unit value for the sake of simplicity.
            , "@Categories"     , ListToString<string>((card as ICard3)?.Categories.Select(x => ListToString<string>(x.Values, ",")), ";") // CATEGORIES  (vCard 3.0+)
            , "@Note"           , card.Notes.PreferedOrFirstProperty?.Text                              // NOTE                         Here we assume only 1 prop for the sake of simplicity.
            , "@Classification" , (card as ICard3)?.Classes.PreferedOrFirstProperty?.Text               // CLASS                        Here we assume only 1 prop for the sake of simplicity.
            , "@ClientAppName"  , clientAppName                                                         // Used to keep custom props created by this CardDAV client when updated by other CardDAV clients.
            ) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }

        // Save custom properties and parameters of this component to [card_CustomProperty] table.
        string customPropsSqlInsert;
        List<object> customPropsParamsInsert;
        if (PrepareSqlCustomPropertiesOfComponentAsync(card, uid, uid, clientAppName, out customPropsSqlInsert, out customPropsParamsInsert))
        {
            await context.ExecuteNonQueryAsync(customPropsSqlInsert, customPropsParamsInsert.ToArray());
        }
    }

    private static string ListToString<T>(IEnumerable<T> arr, string separator = ",")
    {
        if ((arr == null) || !arr.Any())
            return null;
        return string.Join<T>(separator, arr);
    }

    private static SqlParameter CreateVarBinaryParam(string parameterName, string base64)
    {
        SqlParameter param = new SqlParameter(parameterName, SqlDbType.VarBinary);
        if (string.IsNullOrEmpty(base64))
        {
            // To insert NULL to VARBINARY column, SqlParameter must be passed with Size=-1 and Value=DBNull.Value.
            param.Size      = -1;
            param.Value     = DBNull.Value;
        }
        else
        {
            byte[] content  = Convert.FromBase64String(base64);
            param.Size      = content.Length;
            param.Value     = content;
        }
        return param;
    }

    private async Task WriteEmailsAsync(DavContext context, ITextPropertyList<IEmail2> emails, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Email] (
                  [EmailId]
                , [UID]
                , [Type]
                , [Email]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (IEmail2 email in emails)
        {
            valuesSql.Add(string.Format(@"(
                  @EmailId{0}
                , @UID
                , @Type{0}
                , @Email{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid emailId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@EmailId"            +i, emailId
              //, "@UID"
                , "@Type"               +i, ListToString<EmailType>(email.Types)    // EMAIL TYPE param
                , "@Email"              +i, email.Text                              // EMAIL VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(email)                 // EMAIL PREF param
                , "@SortIndex"          +i, email.RawProperty.SortIndex             // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("EMAIL", email.RawProperty, emailId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteAddressesAsync(DavContext context, ICardPropertyList<IAddress2> addresses, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Address] (
                  [AddressId]
                , [UID]
                , [Type]
                , [PoBox]
                , [AppartmentNumber]
                , [Street]
                , [Locality]
                , [Region]
                , [PostalCode]
                , [Country]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (IAddress2 address in addresses)
        {
            valuesSql.Add(string.Format(@"(
                  @AddressId{0}
                , @UID
                , @Type{0}
                , @PoBox{0}
                , @AppartmentNumber{0}
                , @Street{0}
                , @Locality{0}
                , @Region{0}
                , @PostalCode{0}
                , @Country{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid addressId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@AddressId"            +i, addressId
              //, "@UID"
                , "@Type"               +i, ListToString<AddressType>(address.Types)    // ADR TYPE param
                , "@PoBox"              +i, address.PoBox.FirstOrDefault()
                , "@AppartmentNumber"   +i, address.AppartmentNumber.FirstOrDefault()
                , "@Street"             +i, address.Street.FirstOrDefault()
                , "@Locality"           +i, address.Locality.FirstOrDefault()
                , "@Region"             +i, address.Region.FirstOrDefault()
                , "@PostalCode"         +i, address.PostalCode.FirstOrDefault()
                , "@Country"            +i, address.Country.FirstOrDefault()
                , "@PreferenceLevel"    +i, GetPrefParameter(address)                   // ADR PREF param
                , "@SortIndex"          +i, address.RawProperty.SortIndex               // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("ADR", address.RawProperty, addressId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteInstantMessengersAsync(DavContext context, ITextPropertyList<IInstantMessenger3> instantMessengers, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_InstantMessenger] (
                  [InstantMessengerId]
                , [UID]
                , [Type]
                , [InstantMessenger]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (IInstantMessenger3 instantMessenger in instantMessengers)
        {
            valuesSql.Add(string.Format(@"(
                  @InstantMessengerId{0}
                , @UID
                , @Type{0}
                , @InstantMessenger{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid instantMessengerId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@InstantMessengerId" +i, instantMessengerId
              //, "@UID"
                , "@Type"               +i, ListToString<MessengerType>(instantMessenger.Types) // IMPP TYPE param
                , "@InstantMessenger"   +i, instantMessenger.Text                               // IMPP VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(instantMessenger)                  // IMPP PREF param
                , "@SortIndex"          +i, instantMessenger.RawProperty.SortIndex              // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("IMPP", instantMessenger.RawProperty, instantMessengerId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteTelephonesAsync(DavContext context, ITextPropertyList<ITelephone2> telephones, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Telephone] (
                  [TelephoneId]
                , [UID]
                , [Type]
                , [Telephone]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (ITelephone2 telephone in telephones)
        {
            valuesSql.Add(string.Format(@"(
                  @TelephoneId{0}
                , @UID
                , @Type{0}
                , @Telephone{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid telephoneId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@TelephoneId"        +i, telephoneId
              //, "@UID"
                , "@Type"               +i, ListToString<TelephoneType>(telephone.Types)// TEL TYPE param
                , "@Telephone"          +i, telephone.Text                              // TEL VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(telephone)                 // TEL PREF param
                , "@SortIndex"          +i, telephone.RawProperty.SortIndex             // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("TEL", telephone.RawProperty, telephoneId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private async Task WriteUrlsAsync(DavContext context, ICardPropertyList<ICardUriProperty2> urls, string uid, string clientAppName)
    {
        string sql =
            @"INSERT INTO [card_Url] (
                  [UrlId]
                , [UID]
                , [Type]
                , [Url]
                , [PreferenceLevel]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        List<object> parameters = new List<object>(new object[] {
            "@UID", uid
        });

        int i = 0;
        foreach (ICardUriProperty2 url in urls)
        {
            valuesSql.Add(string.Format(@"(
                  @UrlId{0}
                , @UID
                , @Type{0}
                , @Url{0}
                , @PreferenceLevel{0}
                , @SortIndex{0}
            )", i));

            Guid urlId = Guid.NewGuid();

            parameters.AddRange(new object[] {
                  "@UrlId"              +i, urlId
              //, "@UID"
                , "@Type"               +i, ListToString<ExtendibleEnum>(url.Types) // TEL TYPE param 
                , "@Url"                +i, url.Text                                // URL VALUE
                , "@PreferenceLevel"    +i, GetPrefParameter(url)                   // URL PREF param
                , "@SortIndex"          +i, url.RawProperty.SortIndex               // Property position in vCard.
            });

            // Prepare SQL to save custom property parameters to [card_CustomProperty] table.
            string customPropSqlInsert;
            List<object> customPropParametersInsert;
            if (PrepareSqlParamsWriteCustomProperty("URL", url.RawProperty, urlId.ToString(), uid, clientAppName, out customPropSqlInsert, out customPropParametersInsert))
            {
                sql += "; " + customPropSqlInsert;
                parameters.AddRange(customPropParametersInsert);
            }

            i++;
        }

        if (i > 0)
        {
            await context.ExecuteNonQueryAsync(string.Format(sql, string.Join(", ", valuesSql.ToArray())), parameters.ToArray());
        }
    }

    private static byte? GetPrefParameter(ICardMultiProperty prop)
    {
        ICardMultiProperty4 prop4 = prop as ICardMultiProperty4;
        if(prop4 == null)
        {
            return prop.IsPrefered ? (byte?)1 : null;
        }

        return (byte?)prop4.PreferenceLevel;
    }

    private bool PrepareSqlParamsWriteCustomProperty(string propName, IRawProperty prop, string parentId, string uid, string clientAppName, out string sql, out List<object> parameters)
    {
        sql =
            @"INSERT INTO [card_CustomProperty] (
                  [ParentId]
                , [UID]
                , [ClientAppName]
                , [PropertyName]
                , [ParameterName]
                , [Value]
                , [SortIndex]
            ) VALUES {0}";

        List<string> valuesSql = new List<string>();
        parameters = new List<object>();

        int origParamsCount = parameters.Count();

        // Custom properties are one of the following:
        //  - props that start with "X-". This is a standard-based approach to creating custom props.
        //  - props that has "." in its name. Typically "item1.X-PROP". Such props are created by iOS and OS X.
        bool isCustomProp =
            propName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase)
            || propName.Contains(".");


        string paramName = null;

        // Save custom prop value.
        if (isCustomProp)
        {
            string val = prop.RawValue;
            valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @ClientAppName{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            , @SortIndexParam{0}
                            )", paramIndex));

            parameters.AddRange(new object[] {
                              "@ParentId"       + paramIndex, parentId
                            , "@UID"            + paramIndex, uid              // Added for performance optimization purposes.
                            , "@ClientAppName"  + paramIndex, clientAppName    // Client app name that created this custom property.
                            , "@PropertyName"   + paramIndex, propName
                            , "@ParameterName"  + paramIndex, paramName        // null is inserted to mark prop value.
                            , "@Value"          + paramIndex, val
                            , "@SortIndexParam" + paramIndex, prop.SortIndex   // Property position in vCard.
                            });
            paramIndex++;
        }

        // Save parameters and their values.
        foreach (Parameter param in prop.Parameters)
        {
            paramName = param.Name;

            // For standard properties we save only custom params (that start with 'X-'). All standard params go to their fields in DB.
            // For custom properies we save all params.
            if (!isCustomProp && !paramName.StartsWith("X-", StringComparison.InvariantCultureIgnoreCase))
                continue;

            foreach (string value in param.Values)
            {
                string val = value;

                valuesSql.Add(string.Format(@"(
                              @ParentId{0}
                            , @UID{0}
                            , @ClientAppName{0}
                            , @PropertyName{0}
                            , @ParameterName{0}
                            , @Value{0}
                            , @SortIndexParam{0}
                            )", paramIndex));

                parameters.AddRange(new object[] {
                              "@ParentId"       + paramIndex, parentId
                            , "@UID"            + paramIndex, uid          // added for performance optimization purposes
                            , "@ClientAppName"  + paramIndex, clientAppName// Client app name that created this custom parameter.
                            , "@PropertyName"   + paramIndex, propName
                            , "@ParameterName"  + paramIndex, paramName
                            , "@Value"          + paramIndex, val
                            , "@SortIndexParam" + paramIndex, null         // Property position in vCard. Null is inserted for parameter values.
                            });
                paramIndex++;
            }
        }

        if (origParamsCount < parameters.Count())
        {
            sql = string.Format(sql, string.Join(", ", valuesSql.ToArray()));
            return true;
        }
        return false;
    }

    private bool PrepareSqlCustomPropertiesOfComponentAsync(IComponent component, string parentId, string uid, string clientAppName, out string sql, out List<object> parameters)
    {
        sql = "";
        parameters = new List<object>();

        // We save only single custom props here, multiple props are saved in other methods.
        string[] multiProps = new string[] { "EMAIL", "ADR", "IMPP", "TEL", "URL" };

        // Properties in IComponent.Properties are grouped by name.
        foreach (var pair in component.Properties)
        {
            if (multiProps.Contains(pair.Key.ToUpper()) || (pair.Value.Count != 1))
                continue;

            string sqlInsert;
            List<object> parametersInsert;
            if (PrepareSqlParamsWriteCustomProperty(pair.Key, pair.Value.First(), parentId, uid, clientAppName, out sqlInsert, out parametersInsert))
            {
                sql += "; " + sqlInsert;
                parameters.AddRange(parametersInsert);
            }
        }

        return !string.IsNullOrEmpty(sql);
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        string sql = @"DELETE FROM [card_CardFile] 
                       WHERE FileName=@FileName
                       AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)";

        if(await Context.ExecuteNonQueryAsync(sql, 
              "@UserId"   , Context.UserId
            , "@FileName" , fileName) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public async Task ReadAsync(Stream output, long startIndex, long count)
    {
        string vCardVersion = rowCardFile.Field<string>("Version");
        ICard2 card = CardFactory.CreateCard(vCardVersion);

        ReadCard(card);

        ReadEmails(card.Emails, rowsEmails);
        ReadAddresses(card.Addresses, rowsAddresses);
        ReadTelephones(card.Telephones, rowsTelephones);
        ReadUrls(card.Urls, rowsUrls);

        // IMPP is vCard 3.0 & 4.0 prop
        ICard3 card3 = card as ICard3;
        if (card3 != null)
        {
            ReadMessengers(card3.InstantMessengers, rowsInstantMessengers);
        }

        // Check if this CardDAV client application requires properties conversion.
        if (AppleCardInteroperability.NeedsConversion(Context.Request.UserAgent))
        {
            // In case of iOS & OS X the props below must be converted to the following format:
            // item2.TEL:(222)222 - 2222
            // item2.X-ABLabel:Emergency
            AppleCardInteroperability.Denormalize(card);
        }

        new vFormatter().Serialize(output, card);
    }

    private void ReadCard(ICard2 card)
    {
        string uid = rowCardFile.Field<string>("UID");

        //UID
        card.Uid = card.CreateTextProp(uid);


        // PRODID
        card.ProductId = card.CreateTextProp("-//IT Hit//Collab Lib//EN");

        // FN
        card.FormattedNames.Add(rowCardFile.Field<string>("FormattedName"));

        // N
        card.Name = card.CreateNameProp(
            rowCardFile.Field<string>("FamilyName"),
            rowCardFile.Field<string>("GivenName"),
            rowCardFile.Field<string>("AdditionalNames"),
            rowCardFile.Field<string>("HonorificPrefix"),
            rowCardFile.Field<string>("HonorificSuffix"));

        // PHOTO
        if (!rowCardFile.IsNull("Photo"))
        {
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field<byte[]>("Photo")), rowCardFile.Field<string>("PhotoMediaType"), false);
        }

        // LOGO
        if (!rowCardFile.IsNull("Logo"))
        {
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field<byte[]>("Logo")), rowCardFile.Field<string>("LogoMediaType"), false);
        }

        // SOUND
        if (!rowCardFile.IsNull("Sound"))
        {
            card.Photos.Add(Convert.ToBase64String(rowCardFile.Field<byte[]>("Sound")), rowCardFile.Field<string>("SoundMediaType"), false);
        }

        // BDAY
        DateTime? birthday = rowCardFile.Field<DateTime?>("Birthday");
        if (birthday != null)
        {
            card.BirthDate = card.CreateDateProp(birthday.Value, DateComponents.Date);
        }

        // REV
        DateTime? revision = rowCardFile.Field<DateTime?>("RevisionUtc");
        if (revision != null)
        {
            card.Revision = card.CreateDateProp(revision.Value);
        }

        // SORT-STRING
        string sortString = rowCardFile.Field<string>("SortString");
        if (!string.IsNullOrEmpty(sortString))
        {
            ITextProperty2 propSortString = card.CreateProperty<ITextProperty2>();
            propSortString.Text = sortString;
            card.SortString = propSortString;
        }

        // TZ
        string timeZone = rowCardFile.Field<string>("TimeZone");
        if (!string.IsNullOrEmpty(timeZone))
        {
            card.TimeZones.Add(timeZone);
        }

        // GEO

        // TITLE
        string title = rowCardFile.Field<string>("Title");
        if (!string.IsNullOrEmpty(title))
        {
            card.Titles.Add(title);
        }

        // ROLE
        string role = rowCardFile.Field<string>("Role");
        if (!string.IsNullOrEmpty(role))
        {
            card.Roles.Add(role);
        }

        // ORG
        string orgName = rowCardFile.Field<string>("OrgName");
        string orgUnit = rowCardFile.Field<string>("OrgUnit");
        if (!string.IsNullOrEmpty(orgName) || !string.IsNullOrEmpty(orgUnit))
        {
            IOrganization2 propOrg = card.Organizations.CreateProperty();
            propOrg.Name = orgName;
            propOrg.Units = new[] { orgUnit };
            card.Organizations.Add(propOrg);
        }

        // NOTE
        string note = rowCardFile.Field<string>("Note");
        if (!string.IsNullOrEmpty(note))
        {
            card.Notes.Add(note);
        }

        // vCard v3.0 & v4.0 props
        if (card is ICard3)
        {
            ICard3 card3 = card as ICard3;

            // NICKNAME
            string nickname = rowCardFile.Field<string>("Nickname");
            if (!string.IsNullOrEmpty(nickname))
            {
                INickname3 propNickname = card3.NickNames.CreateProperty();
                propNickname.Values = new[] { nickname };
                card3.NickNames.Add(propNickname);
            }

            // CATEGORIES
            string categories = rowCardFile.Field<string>("Categories");
            if (!string.IsNullOrEmpty(categories))
            {
                string[] aCategories = categories.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries);
                foreach (string categoryList in aCategories)
                {
                    ICategories3 catProp = card3.Categories.CreateProperty();
                    catProp.Values = categoryList.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                    card3.Categories.Add(catProp);
                }
            }

            // CLASS
            string classification = rowCardFile.Field<string>("Classification");
            if (!string.IsNullOrEmpty(classification))
            {
                card3.Classes.Add(classification);
            }
        }

        // vCard v4.0 props
        if (card is ICard4)
        {
            ICard4 card4 = card as ICard4;

            // KIND
            string kind = rowCardFile.Field<string>("Kind");
            if (kind != null)
            {
                IKind4 propKind = card4.CreateProperty<IKind4>();
                propKind.Text = kind;
                card4.Kind = propKind;
            }

            // ANNIVERSARY
            DateTime? anniversary = rowCardFile.Field<DateTime?>("Anniversary");
            if (anniversary != null)
            {
                IAnniversary4 propAnniversary = card4.CreateProperty<IAnniversary4>();
                propAnniversary.Value = new Date(anniversary.Value, DateComponents.Month | DateComponents.Date);
                card4.Anniversary = propAnniversary;
            }
            
            
            // GENDER
            string gender = rowCardFile.Field<string>("Gender");
            if (!string.IsNullOrEmpty(gender))
            {
                IGender4 propGender = card4.CreateProperty<IGender4>();
                propGender.Text = gender;
                card4.Gender = propGender;
            }
            
            // LANG
            string language = rowCardFile.Field<string>("Language");
            if (!string.IsNullOrEmpty(language))
            {
                card4.ContactLanguages.Add(language);
            }
        }


        // Get custom properties and custom parameters
        IEnumerable<DataRow> rowsCardCustomProperties = rowsCustomProperties.Where(x => x.Field<string>("ParentId") == uid);
        ReadCustomProperties(card, rowsCardCustomProperties);
    }


    private void ReadEmails(ITextPropertyList<IEmail2> emails, IEnumerable<DataRow> rowsEmails)
    {
        foreach (DataRow rowEmail in rowsEmails)
        {
            IEmail2 email = emails.CreateProperty();
            email.Text  = rowEmail.Field<string>("Email");                              // EMAIL value
            email.Types = ParseType<EmailType>(rowEmail.Field<string>("Type"));         // TYPE param
            SetPrefParameter(email, rowEmail.Field<byte?>("PreferenceLevel"));          // PREF param
            email.RawProperty.SortIndex = rowEmail.Field<int>("SortIndex");             // Property position in vCard.
            AddParamValues(rowEmail.Field<Guid>("EmailId"), email.RawProperty);         // Add custom parameters from [card_CustomProperty] table.
            emails.Add(email);
        }
    }

    private void ReadAddresses(ICardPropertyList<IAddress2> addresses, IEnumerable<DataRow> rowsAddresses)
    {
        foreach (DataRow rowAddress in rowsAddresses)
        {
            IAddress2 address = addresses.CreateProperty();
            address.SetAddress(
                new[] { rowAddress.Field<string>("PoBox") },
                new[] { rowAddress.Field<string>("AppartmentNumber")},
                new[] { rowAddress.Field<string>("Street")},
                new[] { rowAddress.Field<string>("Locality")},
                new[] { rowAddress.Field<string>("Region")},
                new[] { rowAddress.Field<string>("PostalCode")},
                new[] { rowAddress.Field<string>("Country")},
                ParseType<AddressType>(rowAddress.Field<string>("Type")));              // ADR value and TYPE param                
            SetPrefParameter(address, rowAddress.Field<byte?>("PreferenceLevel"));      // PREF param
            address.RawProperty.SortIndex = rowAddress.Field<int>("SortIndex");         // Property position in vCard.
            AddParamValues(rowAddress.Field<Guid>("AddressId"), address.RawProperty);   // Add custom parameters from [card_CustomProperty] table.
            addresses.Add(address);
        }
    }

    private void ReadMessengers(ITextPropertyList<IInstantMessenger3> messengers, IEnumerable<DataRow> rowsMessengers)
    {
        foreach (DataRow rowMessenger in rowsMessengers)
        {
            IInstantMessenger3 messenger = messengers.CreateProperty();
            messenger.Text  = rowMessenger.Field<string>("InstantMessenger");                       // IMPP value
            messenger.Types = ParseType<MessengerType>(rowMessenger.Field<string>("Type"));         // TYPE param
            SetPrefParameter(messenger, rowMessenger.Field<byte?>("PreferenceLevel"));              // PREF param
            messenger.RawProperty.SortIndex = rowMessenger.Field<int>("SortIndex");                 // Property position in vCard.
            AddParamValues(rowMessenger.Field<Guid>("InstantMessengerId"), messenger.RawProperty);  // Add custom parameters from [card_CustomProperty] table.
            messengers.Add(messenger);
        }
    }

    private void ReadTelephones(ITextPropertyList<ITelephone2> telephones, IEnumerable<DataRow> rowsTelephones)
    {
        foreach (DataRow rowTelephone in rowsTelephones)
        {
            ITelephone2 telephone = telephones.CreateProperty();
            telephone.Text  = rowTelephone.Field<string>("Telephone");                      // TEL value
            telephone.Types = ParseType<TelephoneType>(rowTelephone.Field<string>("Type")); // TYPE param
            SetPrefParameter(telephone, rowTelephone.Field<byte?>("PreferenceLevel"));      // PREF param
            telephone.RawProperty.SortIndex = rowTelephone.Field<int>("SortIndex");         // Property position in vCard.
            AddParamValues(rowTelephone.Field<Guid>("TelephoneId"), telephone.RawProperty); // Add custom parameters from [card_CustomProperty] table.
            telephones.Add(telephone);
        }
    }

    private void ReadUrls(ICardPropertyList<ICardUriProperty2> urls, IEnumerable<DataRow> rowsUrls)
    {
        foreach (DataRow rowUrl in rowsUrls)
        {
            ICardUriProperty2 url = urls.CreateProperty();
            url.Text  = rowUrl.Field<string>("Url");                                    // URL value
            url.Types = ParseType<ExtendibleEnum>(rowUrl.Field<string>("Type"));        // TYPE param
            SetPrefParameter(url, rowUrl.Field<byte?>("PreferenceLevel"));              // PREF param
            url.RawProperty.SortIndex = rowUrl.Field<int>("SortIndex");                 // Property position in vCard.
            AddParamValues(rowUrl.Field<Guid>("UrlId"), url.RawProperty);               // Add custom parameters from [card_CustomProperty] table.
            urls.Add(url);
        }
    }

    private static void SetPrefParameter(ICardMultiProperty prop, byte? preferenceLevel)
    {
        if (preferenceLevel != null)
        {
            ICardMultiProperty4 prop4 = prop as ICardMultiProperty4;
            if (prop4 == null)
            {
                // vCard 2.1 & 3.0
                prop.IsPrefered = true;
            }
            else
            {
                // vCard 4.0
                prop4.PreferenceLevel = preferenceLevel.Value;
            }
        }
    }

    private static T[] ParseType<T>(string typesList) where T : ExtendibleEnum, new()
    {
        if (!string.IsNullOrEmpty(typesList))
        {
            string[] aStrTypes = typesList.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            return aStrTypes.Select(x => StringToEnum<T>(x)).ToArray();
        }

        return new T[] { };
    }

    private static void ReadCustomProperties(IComponent component, IEnumerable<DataRow> rowsCustomProperies)
    {
        foreach (DataRow rowCustomProperty in rowsCustomProperies)
        {
            string propertyName = rowCustomProperty.Field<string>("PropertyName");

            IRawProperty prop;
            if (!component.Properties.ContainsKey(propertyName))
            {
                prop = component.CreateRawProperty();
                component.AddProperty(propertyName, prop);
            }
            else
            {
                prop = component.Properties[propertyName].FirstOrDefault();
            }

            string paramName = rowCustomProperty.Field<string>("ParameterName");
            string value = rowCustomProperty.Field<string>("Value");
            if (paramName == null)
            {
                // If ParameterName is null the Value contains property value
                prop.RawValue = value;
                prop.SortIndex = rowCustomProperty.Field<int>("SortIndex"); // Property position in vCard.
            }
            else
            {
                prop.Parameters.Add(new Parameter(paramName, value));
            }
        }
    }

    private void AddParamValues(Guid propertyId, IRawProperty prop)
    {
        IEnumerable<DataRow> rowsCustomParams = rowsCustomProperties.Where(x => x.Field<string>("ParentId") == propertyId.ToString());
        foreach (DataRow rowCustomParam in rowsCustomParams)
        {
            string paramName = rowCustomParam.Field<string>("ParameterName");
            string paramValue = rowCustomParam.Field<string>("Value");
            prop.Parameters.Add(new Parameter(paramName, paramValue));
        }
    }

    private static T StringToEnum<T>(string value) where T : ExtendibleEnum, new()
    {
        if (value == null)
            return null;

        T res;
        if (!ExtendibleEnum.TryFromString<T>(value, out res))
        {
            // If no matching value is found create new ExtendibleEnum or type T 
            // with specified string value and default numeric value (-1).
            res = new T();
            res.Name = value;
        }

        return res;
    }
}
]]></code>
    </example>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookFolder">
            <summary>
            Represents address book on a CardDAV server.
            </summary>
            <remarks>
            <para>
            Items of this type represent folder that contain business card files.
            </para>
            <para>
            An address book folder can contain business card files (items that implement <see cref="T:ITHit.WebDAV.Server.CardDav.ICardFile"/>) 
            and folders that are NOT <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookFolder"/> folders. 
            "Nesting" of address book folders within other address book folders at any depth is NOT allowed.
            </para>
            <para>http://tools.ietf.org/html/rfc6352#section-5.2</para>
            </remarks>
            <example>
      <para>The code below is part of 'CardDAVServer.SqlStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class AddressbookFolder : DavHierarchyItem, IAddressbookFolderAsync, ICurrentUserPrincipalAsync, IAclHierarchyItemAsync
{
    public static async Task<IAddressbookFolderAsync> LoadByIdAsync(DavContext context, Guid addressbookFolderId)
    {
        // Load only address book that the use has access to. 
        // Also load complete ACL for this address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access]
              WHERE [AddressbookFolderId] = @AddressbookFolderId
              AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return (await LoadAsync(context, sql,
              "@UserId"             , context.UserId
            , "@AddressbookFolderId", addressbookFolderId
            )).FirstOrDefault();
    }

    public static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAllAsync(DavContext context)
    {
        // Load only address books that the use has access to. 
        // Also load complete ACL for each address book, but only if user has access to that address book.
        string sql =
            @"SELECT * FROM [card_AddressbookFolder] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)

            ; SELECT * FROM [card_Access] 
              WHERE [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId)";

        return await LoadAsync(context, sql, "@UserId", context.UserId);
    }

    private static async Task<IEnumerable<IAddressbookFolderAsync>> LoadAsync(DavContext context, string sql, params object[] prms)
    {
        IList<IAddressbookFolderAsync> addressbookFolders = new List<IAddressbookFolderAsync>();

        using (SqlDataReader reader = await context.ExecuteReaderAsync(sql, prms))
        {
            DataTable addressbooks = new DataTable();
            addressbooks.Load(reader);

            DataTable access = new DataTable();
            access.Load(reader);

            foreach (DataRow rowAddressbookFolder in addressbooks.Rows)
            {
                Guid addressbookFolderId = rowAddressbookFolder.Field<Guid>("AddressbookFolderId");

                string filter = string.Format("AddressbookFolderId = '{0}'", addressbookFolderId);
                DataRow[] rowsAccess = access.Select(filter);

                addressbookFolders.Add(new AddressbookFolder(context, addressbookFolderId, rowAddressbookFolder, rowsAccess));
            }
        }

        return addressbookFolders;
    }

    internal static async Task CreateAddressbookFolderAsync(DavContext context, string name, string description)
    {
        // 1. Create address book.
        // 2. Grant owner privileges to the user on the created address book(s).
        string sql = @"INSERT INTO [card_AddressbookFolder] (
                      [AddressbookFolderId]
                    , [Name]
                    , [Description]
                ) VALUES (
                      @AddressbookFolderId
                    , @Name
                    , @Description
                )
                ; INSERT INTO [card_Access] (
                      [AddressbookFolderId]
                    , [UserId]
                    , [Owner]
                    , [Read]
                    , [Write]
                ) VALUES (
                      @AddressbookFolderId
                    , @UserId
                    , @Owner
                    , @Read
                    , @Write
                )";

        Guid addressbookFolderId = Guid.NewGuid();

        await context.ExecuteNonQueryAsync(sql,
              "@AddressbookFolderId", addressbookFolderId
            , "@Name"               , name
            , "@Description"        , description
            , "@UserId"             , context.UserId
            , "@Owner"              , true
            , "@Read"               , true
            , "@Write"              , true
            );
    }

    private readonly Guid addressbookFolderId;

    private readonly DataRow rowAddressbookFolder;

    private readonly DataRow[] rowsAccess;

    public override string Name
    {
        get { return rowAddressbookFolder != null ? rowAddressbookFolder.Field<string>("Name") : null; }
    }

    public override string Path
    {
        get
        {
            return string.Format("{0}{1}/", AddressbooksRootFolder.AddressbooksRootFolderPath, addressbookFolderId);
        }
    }

    private AddressbookFolder(DavContext context, Guid addressbookFolderId, DataRow addressbook, DataRow[] rowsAccess)
        : base(context)
    {
        this.addressbookFolderId    = addressbookFolderId;
        this.rowAddressbookFolder   = addressbook;
        this.rowsAccess             = rowsAccess;
    }

    public async Task<IEnumerable<ICardFileAsync>> MultiGetAsync(IEnumerable<string> pathList, IEnumerable<PropertyName> propNames)
    {
        // Get list of file names from path list.
        IEnumerable<string> fileNames = pathList.Select(a => System.IO.Path.GetFileNameWithoutExtension(a));

        return await CardFile.LoadByFileNamesAsync(Context, fileNames, PropsToLoad.All);
    }

    public async Task<IEnumerable<ICardFileAsync>> QueryAsync(string rawQuery, IEnumerable<PropertyName> propNames)
    {
        // For the sake of simplicity we just call GetChildren returning all items. 
        // Typically you will return only items that match the query.
        return (await GetChildrenAsync(propNames.ToList())).Cast<ICardFileAsync>();
    }

    public string AddressbookDescription 
    {
        get { return rowAddressbookFolder.Field<string>("Description"); }
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetChildrenAsync(IList<PropertyName> propNames)
    {
        // Here we enumerate all business cards contained in this address book.
        // You can filter children items in this implementation and 
        // return only items that you want to be available for this 
        // particular user.

        // Typically only getcontenttype and getetag properties are requested in GetChildren call by CalDAV/CardDAV clients.
        // The iCalendar/vCard (calendar-data/address-data) is typically requested not in GetChildren, but in a separate multiget 
        // report, in MultiGetAsync() method call, that follows this request.

        // Bynari submits PROPFIND without props - Engine will request getcontentlength

        IList<IHierarchyItemAsync> children = new List<IHierarchyItemAsync>();
        return await CardFile.LoadByAddressbookFolderIdAsync(Context, addressbookFolderId, PropsToLoad.Minimum);
    }

    public async Task<IFileAsync> CreateFileAsync(string name)
    {
        // The actual business card file is created in datatbase in CardFile.Write call.
        string fileName = System.IO.Path.GetFileNameWithoutExtension(name);
        return CardFile.CreateCardFile(Context, addressbookFolderId, fileName);
    }

    public async Task CreateFolderAsync(string name)
    {
        throw new DavException("Not allowed.", DavStatus.NOT_ALLOWED);
    }

    public override async Task MoveToAsync(IItemCollectionAsync destFolder, string destName, MultistatusException multistatus)
    {
        // Here we support only addressbooks renaming. Check that user has permissions to write.
        string sql = @"UPDATE [card_AddressbookFolder] SET Name=@Name 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Write] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql, 
              "@Name"               , destName
            , "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task DeleteAsync(MultistatusException multistatus)
    {
        // Delete address book and all vCards associated with it. Check that user has permissions to delete.
        string sql = @"DELETE FROM [card_AddressbookFolder] 
            WHERE [AddressbookFolderId]=@AddressbookFolderId
            AND [AddressbookFolderId] IN (SELECT [AddressbookFolderId] FROM [card_Access] WHERE [UserId]=@UserId AND [Owner] = 1)";

        if (await Context.ExecuteNonQueryAsync(sql,
              "@UserId"             , Context.UserId
            , "@AddressbookFolderId", addressbookFolderId) < 1)
        {
            throw new DavException("Item not found or you do not have enough permissions to complete this operation.", DavStatus.FORBIDDEN);
        }
    }

    public override async Task<IEnumerable<PropertyValue>> GetPropertiesAsync(IList<PropertyName> names, bool allprop)
    {
        IList<PropertyValue> propVals = await GetPropertyValuesAsync(
                "SELECT [Name], [Namespace], [PropVal] FROM [card_AddressbookFolderProperty] WHERE [AddressbookFolderId] = @AddressbookFolderId",
                "@AddressbookFolderId", addressbookFolderId);

        if (allprop)
        {
            return propVals;
        }
        else
        {
            IList<PropertyValue> requestedPropVals = new List<PropertyValue>();
            foreach (PropertyValue p in propVals)
            {
                if (names.Contains(p.QualifiedName))
                {
                    requestedPropVals.Add(p);
                }
            }
            return requestedPropVals;
        }
    }

    public override async Task UpdatePropertiesAsync(
        IList<PropertyValue> setProps,
        IList<PropertyName> delProps,
        MultistatusException multistatus)
    {
        foreach (PropertyValue p in setProps)
        {
            await SetPropertyAsync(p); // create or update property
        }

        foreach (PropertyName p in delProps)
        {
            await RemovePropertyAsync(p.Name, p.Namespace);
        }
    }

    private async Task<IList<PropertyValue>> GetPropertyValuesAsync(string command, params object[] prms)
    {
        List<PropertyValue> l = new List<PropertyValue>();
        
        using (SqlDataReader reader = await Context.ExecuteReaderAsync(command, prms))
        {
            while (reader.Read())
            {
                string name = reader.GetString(reader.GetOrdinal("Name"));
                string ns = reader.GetString(reader.GetOrdinal("Namespace"));
                string value = reader.GetString(reader.GetOrdinal("PropVal"));
                l.Add(new PropertyValue(new PropertyName(name, ns), value));
            }
        }

        return l;
    }

    private async Task SetPropertyAsync(PropertyValue prop)
    {
        string selectCommand =
            @"SELECT Count(*) FROM [card_AddressbookFolderProperty]
              WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

        int count = await Context.ExecuteScalarAsync<int>(
            selectCommand,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , prop.QualifiedName.Name,
            "@Namespace"            , prop.QualifiedName.Namespace);

        // insert
        if (count == 0)
        {
            string insertCommand = @"INSERT INTO [card_AddressbookFolderProperty] ([AddressbookFolderId], [Name], [Namespace], [PropVal])
                                      VALUES(@AddressbookFolderId, @Name, @Namespace, @PropVal)";

            await Context.ExecuteNonQueryAsync(
                insertCommand,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
        else
        {
            // update
            string command = @"UPDATE [card_AddressbookFolderProperty]
                  SET [PropVal] = @PropVal
                  WHERE [AddressbookFolderId] = @AddressbookFolderId AND [Name] = @Name AND [Namespace] = @Namespace";

            await Context.ExecuteNonQueryAsync(
                command,
                "@PropVal"              , prop.Value,
                "@AddressbookFolderId"  , addressbookFolderId,
                "@Name"                 , prop.QualifiedName.Name,
                "@Namespace"            , prop.QualifiedName.Namespace);
        }
    }

    private async Task RemovePropertyAsync(string name, string ns)
    {
        string command = @"DELETE FROM [card_AddressbookFolderProperty]
                          WHERE [AddressbookFolderId] = @AddressbookFolderId
                          AND [Name] = @Name
                          AND [Namespace] = @Namespace";

        await Context.ExecuteNonQueryAsync(
            command,
            "@AddressbookFolderId"  , addressbookFolderId,
            "@Name"                 , name,
            "@Namespace"            , ns);
    }

    public Task SetOwnerAsync(IPrincipalAsync value)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<IPrincipalAsync> GetOwnerAsync()
    {
        DataRow rowOwner = rowsAccess.FirstOrDefault(x => x.Field<bool>("Owner") == true);
        if (rowOwner == null)
            return null;

        return await Acl.User.GetUserAsync(Context, rowOwner.Field<string>("UserId"));
    }

    public Task SetGroupAsync(IPrincipalAsync value)
    {
        throw new DavException("Group cannot be set", DavStatus.FORBIDDEN);
    }

    public async Task<IPrincipalAsync> GetGroupAsync()
    {
        return null; // Groups are not supported.
    }

    public async Task<IEnumerable<SupportedPrivilege>> GetSupportedPrivilegeSetAsync()
    {
        return new[] {
            new SupportedPrivilege
            {
                Privilege = Privilege.Read, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies the user the ability to read content and properties of files/folders."
            },
            new SupportedPrivilege
            {
                Privilege = Privilege.Write, IsAbstract = false, DescriptionLanguage = "en",
                Description = "Allows or denies locking an item or modifying the content, properties, or membership of a collection."
            }
        };
    }

    public async Task<IEnumerable<Privilege>> GetCurrentUserPrivilegeSetAsync()
    {
        DataRow rowAccess = rowsAccess.FirstOrDefault(x => x.Field<string>("UserId")== Context.UserId);
        if (rowAccess == null)
            return null;

        List<Privilege> privileges = new List<Privilege>();
        if (rowAccess.Field<bool>("Read"))
            privileges.Add(Privilege.Read);

        if (rowAccess.Field<bool>("Write"))
            privileges.Add(Privilege.Write);

        return privileges;
    }

    public async Task<IEnumerable<ReadAce>> GetAclAsync(IList<PropertyName> propertyNames)
    {
        IList<ReadAce> aceList = new List<ReadAce>();
        foreach (DataRow rowAccess in rowsAccess)
        {
            ReadAce ace = new ReadAce();
            ace.Principal = await Acl.User.GetUserAsync(Context, rowAccess.Field<string>("UserId"));
            if (rowAccess.Field<bool>("Read"))
                ace.GrantPrivileges.Add(Privilege.Read);
            if (rowAccess.Field<bool>("Write"))
                ace.GrantPrivileges.Add(Privilege.Write);

            ace.IsProtected = rowAccess.Field<bool>("Owner");
            aceList.Add(ace);
        }
        return aceList;
    }

    public Task SetAclAsync(IList<WriteAce> aces)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }

    public async Task<AclRestriction> GetAclRestrictionsAsync()
    {
        return new AclRestriction { NoInvert = true, GrantOnly = true };
    }

    public async Task<IEnumerable<IHierarchyItemAsync>> GetInheritedAclSetAsync()
    {
        return new IHierarchyItemAsync[] { };
    }

    public async Task<IEnumerable<IPrincipalFolderAsync>> GetPrincipalCollectionSetAsync()
    {
        return new IPrincipalFolderAsync[] { new Acl.UsersFolder(Context) };
    }

    public async Task<IPrincipalAsync> ResolveWellKnownPrincipalAsync(WellKnownPrincipal wellKnownPrincipal)
    {
        return null;
    }

    public Task<IEnumerable<IAclHierarchyItemAsync>> GetItemsByPropertyAsync(MatchBy matchBy, IList<PropertyName> props)
    {
        throw new DavException("Not implemented.", DavStatus.NOT_IMPLEMENTED);
    }
}
]]></code>
    </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.CardDav.IAddressbookFolder.AddressbookDescription">
            <summary>
            Gets a human-readable description of the address book.
            </summary>
            <remarks>
            http://tools.ietf.org/html/rfc4791#section-5.2.1
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.IAddressbookPrincipal">
            <summary>
            Represents principal on a server that supports CardDAV.
            </summary>
            <remarks>
            This is the marker interface, it does not provide any methods or properties in 
            addition to provided by <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipal"/> and <see cref="T:ITHit.WebDAV.Server.CardDav.IAddressbookItem"/> interfaces.  
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockLevel">
            <summary>
            Level of lock.
            </summary>
            <remarks>
            If a user sets an exclusive lock, other users will not be able to set any locks. If a user sets shared lock 
            other users will be able to set only shared lock on the item. There could be only 1 exclusive lock set on an 
            item or it can have 1 or more shared locks.
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.Class2.LockLevel.Shared">
            <summary>
            Shared lock.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Class2.LockLevel.Exclusive">
            <summary>
            Exclusive lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.RefreshLockResult">
            <summary>
            Result of <see cref="M:ITHit.WebDAV.Server.Class2.ILock.RefreshLock(System.String,System.Nullable{System.TimeSpan})"/> operation.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.RefreshLockResult.#ctor(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.TimeSpan,System.String)">
            <summary>
            Initializes a new instance of the RefreshLockResult class.
            </summary>
            <param name="isDeep">Indicates whether a lock is enforceable on the subtree.</param>
            <param name="level">Determines whether lock is shared.</param>
            <param name="owner">Principal taking out a lock.</param>
            <param name="timeOut">Timeout value. TimeSpan.MaxValue means 'never'.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.Level">
            <summary>
            Determines whether lock is isShared.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.IsDeep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.TimeOut">
            <summary>
            Gets/sets timeout.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.RefreshLockResult.Owner">
            <summary>
            Gets/sets information about the principal taking out a lock.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ArgumentUtil">
            <summary>
            Utility to check arguments.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ArgumentUtil.CheckArgumentNotNull(System.Object,System.String)">
            <summary>
            Checks that argument is not null.
            </summary>
            <param name="obj">Argument to check.</param>
            <param name="paramName">Argument name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ArgumentUtil.CheckArgument(System.Boolean,System.String)">
            <summary>
            Checks argument for certain condition.
            </summary>
            <param name="b">Condition result.</param>
            <param name="s">Argument name.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.QueryReportHandler">
            <summary>
            Base class for processing <b>calendar-query</b> report and <b>addressbook-query</b> reports.
            </summary>    
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IReportHandler">
            <summary>
            Provides point of extension to REPORT requests.
            </summary>
            <remarks>
            If you need to implement your own report,
            implement this interface and register it with <see cref="M:ITHit.WebDAV.Server.DavEngine.RegisterReportHandler(System.String,System.String,ITHit.WebDAV.Server.Extensibility.IReportHandler)"/> method.
            Engine will call this handler when it needs to execute a report.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IReportHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Determines whether this report can be executed for an item.
            </summary>
            <param name="item">Item to determine whether the report applies to it.</param>
            <returns><c>true</c> if the report applies to the item.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IReportHandler.HandleReport(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem,System.Xml.XmlElement)">
            <summary>
            Generates report response.
            </summary>
            <param name="context">Context.</param>
            <param name="item">Item for which request is sent.</param>
            <param name="reportElement">Root request XML element.</param>
            <returns>
            .
            </returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.QueryReportHandler.GetDepth(ITHit.WebDAV.Server.Extensibility.DavRequest)">
            <summary>
            The request MAY include a Depth header.  If no Depth header is included, Depth:0 is assumed.
            http://tools.ietf.org/html/rfc4791#section-7.8
            </summary>
            <returns>
            This implementation is different from the ITHit.WebDAV.Server.Impl.Util.DavRequestExtensions.GetDepth() 
            implementation. This one returns 1 in case Depth heder is not present.
            </returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.InvalidLicenseException">
            <summary>
            Exception that indicates that the license is invalid.
            </summary>
            <remarks>The license is invalid.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseValidator">
            <summary>
            Validates license file.
            </summary>
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.License.LicenseValidator.Modules">
            <summary>
            Contains names of modules
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.SearchDavHandler">
            <summary>
            Summary description for SearchDavHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseDavHandler">
            <summary>
            Summary description for BaseDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IMethodHandler">
            <summary>
            Represents HTTP method handler.
            </summary>
            <remarks>
            <para>
            The IT Hit WebDAV Server Engine allows creating custom HTTP handlers and replacing original engine handlers. 
            To add or replace handler call <see cref="M:ITHit.WebDAV.Server.DavEngine.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.Extensibility.IMethodHandler)"/> method passing HTTP method
            name and object instance 
            implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IMethodHandler"/>. The original handler, if any, 
            is returned from <see cref="M:ITHit.WebDAV.Server.DavEngine.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.Extensibility.IMethodHandler)"/> method. 
            </para>
            <para>
            The <see cref="M:ITHit.WebDAV.Server.Extensibility.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem)"/> method of this interface is called by the engine during 
            <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> call. 
            The hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> is passed to ProcessRequest 
            method as a parameter.
            </para>
            </remarks>
            <remarks>
            The handler must call <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> when all update methods have been called and 
            the handler is about 
            to start writing response.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IMethodHandler&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Enables processing of HTTP Web requests by a custom handler.
            </summary>
            <param name="context">
             Instance of your context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class.
            </param>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> or 
            <b>null</b>.
            </param>
            <returns>
            .
            </returns>
            <remarks>The <see cref="M:ITHit.WebDAV.Server.Extensibility.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem)"/> method is called by the engine during <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> 
            call. The hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> is 
            passed to this method.  If <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> returns null the null is passed.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IMethodHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Determines whether this method shall be enlisted in 'supported-method-set' for 
            <paramref name="item"/>.
            </summary>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> or 
            <b>null</b>.</param>
            <returns>Boolean indicating whether this handler implementation can handle request for the item.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IMethodHandler.EnableOutputBuffering">
            <summary>
            Determines whether engine can buffer content to calculate content length.
            </summary>
            <returns>
            Boolean indicating whether content shall be buffered to calculated content length.
            Engine will look at this property only if <see cref="P:ITHit.WebDAV.Server.DavEngine.CalculateContentLength"/> is true.
            </returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IMethodHandler.EnableOutputDebugLogging">
            <summary>
            Determines whether output produces by this handler shall be logged if debug logging
            is enabled.
            </summary>
            <returns>Boolean indicating whether output shall be logged in debug mode.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IMethodHandler.EnableInputDebugLogging">
            <summary>
            Determines whether input read by this handler shall be logged if debug logging is enabled.
            </summary>
            <returns>Boolean indicating whether input shall be logged in debug mode.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Sharing">
            <summary>
            WebDAV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcalendarDAVHandler">
            <summary>
             An HTTP request using the MKCALENDAR method creates a new calendar collection resource.
            </summary>
            <remarks>
            The implementation is not optimal, because it makes extra call to GetHierarchyItem in 
            case url is not eaquel to displayname
            http://tools.ietf.org/html/rfc4791#section-5.3.1
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcalendarDAVHandler.ProcessRequest(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            When creating new calendars iCal submits request that looks like the following:
            MKCALENDAR https://base/calendars/Volodymyr/423C82A5-CB6F-475D-A564-3AA73C5EAA39/
            but specifies display name in the displayname property, which is totally according to RFC
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IOptionsHandler">
            <summary>
            Provides point of extension to OPTIONS request.
            </summary>
            <remarks>
            If you need to implement your own extension to WebDAV and add token to DAV header in OPTIONS response,
            implement this interface and register it with <see cref="M:ITHit.WebDAV.Server.DavEngine.RegisterOptionsHandler(System.String,ITHit.WebDAV.Server.Extensibility.IOptionsHandler)"/> method
            passing token as first argument to it.
            When building DAV header engine will call all registered options handlers to determine if this particular
            options is available for the item.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IOptionsHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            The method is called to determine if the option is available for the item and shall be
            enlisted in DAV header for OPTIONS response.
            </summary>
            <param name="item">Item for which request is made.</param>
            <returns><c>true</c>if option token shall be enlisted.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IPropertyHandler">
            <summary>
            Provides point of extension to PROPFIND, PROPPATCH requests.
            </summary>
            <remarks>
            If you need to implement your own live property,
            implement this interface and register it with <see cref="M:ITHit.WebDAV.Server.DavEngine.RegisterPropertyHandler(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.Extensibility.IPropertyHandler)"/> method.
            Engine will call this handler when it needs to read/write the property.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandler.Write(System.Xml.XmlWriter,ITHit.WebDAV.Server.IHierarchyItem,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Writes property value to xml writer.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write property value.</param>
            <param name="item">Item for which to retrieve property.</param>
            <param name="context">Context.</param> 
            <returns>
            .
            </returns>       
            <remarks>
            Property writer shall retrieve and validate all values first and only then write anything to writer.
            Otherwise exception may be thrown while retrieving properties and output XML will be broken.
            </remarks>        
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandler.Update(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem,System.Xml.XmlElement)">
            <summary>
            Updates value of property.
            </summary>
            <param name="context">Context.</param>
            <param name="item">Item in which to update property.</param>
            <param name="value">Xml with property value.</param>
            <returns>
            .
            </returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.IPropertyHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Determines whether this property can be set/retrieved form an item.
            </summary>
            <param name="item">Item to determine whether property applies to it.</param>
            <returns><c>true</c> if the property applies to the item.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IPropertyHandler.IsReadonly">
            <summary>
            Gets a value indicating whether the property is readonly and cannot be updated.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.IPropertyHandler.IncludeInAllProp">
            <summary>
            Gets a value indicating whether the property shall be included in 'allprop' response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.AllowedSharingModes">
            <summary>
            Defines allowed sharing modes for calendar.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.5.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.Invite">
            <summary>
            Used to show to whom a calendar has been shared.
            </summary>
            <remarks>
            http://svn.calendarserver.org/repository/calendarserver/CalendarServer/trunk/doc/Extensions/caldav-sharing.txt
            (Section 5.2.2)
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CardDav.AddressbookHomeSet">
            <summary>
            Identifies the URL of any WebDAV collections that contain
            address book collections owned by the associated principal
            resource.
            </summary>
            <remarks>
            http://tools.ietf.org/html/rfc6352#section-7.1.1
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.PropertyHandlers.CalDav.CalendarHomeSet">
            <summary>
            Identifies the URL of any WebDAV collections that contain
            calendar collections owned by the associated principal resource.
            </summary>
            <remarks>
            <para>
            This property SHOULD be defined on a principal
            resource.  If defined, it MAY be protected and SHOULD NOT be
            returned by a PROPFIND DAV:allprop request (as defined in Section
            12.14.1 of [RFC2518]).
            </para>
            <para>
            The CALDAV:calendar-home-set property is meant to allow
             users to easily find the calendar collections owned by the
             principal.  Typically, users will group all the calendar
             collections that they own under a common collection.  This
             property specifies the URL of collections that are either calendar
             collections or ordinary collections that have child or descendant
             calendar collections owned by the principal.
             </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.MultigetReportHandler">
            <summary>
            Base class for processing <b>calendar-multiget</b> report and <b>addressbook-multiget</b> reports.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarMultigetReportHandler.GetHierarchyItems(ITHit.WebDAV.Server.IHierarchyItem,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns items requested by the client.
            </summary>
            <param name="pathList">Paths of the items requested by the client.</param>
            <param name="propNames">List of properties requested by the client.</param>
            <returns>List of items.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.CalDav.CalendarQueryReportHandler">
            <summary>
            Processes calendar-query report.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ReportHandlers.CardDav.AddressbookMultigetReportHandler.GetHierarchyItems(ITHit.WebDAV.Server.IHierarchyItem,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns items requested by the client.
            </summary>
            <param name="pathList">Paths of the items requested by the client.</param>
            <param name="propNames">List of properties requested by the client.</param>
            <returns>List of items.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ReportHandlers.CardDav.AddressbookQueryReportHandler">
            <summary>
            Processes addressbook-query report.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Url">
            <summary>
            TODO: Update summary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.LogFlagsEnum">
            <summary>
            Logging options.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.LogFlagsEnum.LogGetResponseBody">
            <summary>
            If this flag is set the GET response body will be logged.
            </summary>
            <remarks>
            <para>
            The body of the GET response may be very large and often not human readable. 
            </para>
            <para>
            It make sense to enable GET body logging for CalDAV and CardDAV servers and disable in other cases.
            </para>
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.LogFlagsEnum.LogPutRequestBody">
            <summary>
            If this flag is set the PUT request body will be logged.
            </summary>
            <remarks>
            <para>
            The body of the PUT request may be very large and often not human readable. 
            </para>
            <para>
            It make sense to enable PUT body logging for CalDAV and CardDAV servers and disable in other cases.
            </para>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.NamespaceDoc">
            <summary>
            This namespace provides classes for accessing WebDAV server items, file structure management, properties management.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating server which supports user and permissions management.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating calendar server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CalDav.iTip.NamespaceDoc">
            <summary>
            This namespace provides interfaces and classes for managing iCalendar Transport-Independent Interoperability Protocol (iTIP).
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.CardDav.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating CardDAV server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class1.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating basic Class1 compliant WebDav server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating Class2 compliant WebDav server (with locking support).
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating DeltaV server items and version controlling.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.NamespaceDoc">
            <summary>
            This namespace provides interfaces for extending the engine with support of different methods, properties etc.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.NamespaceDoc">
            <summary>
            This namespace provides interfaces and classes for managing Internet Calendaring and Scheduling (iCalendar) format.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Components.NamespaceDoc">
            <summary>
            iCalendar components
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Components.Properties.NamespaceDoc">
            <summary>
            iCalendar components properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.PropertyParameters.NamespaceDoc">
            <summary>
            iCalendar PropertyParameters
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.iCalendar.Serialization.NamespaceDoc">
            <summary>
            This namespace provides classes for storing and retriving iCalendars.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.NamespaceDoc">
            <summary>
            The ITHit.WebDav.Server.Logger namespace provides DefaultLogger class. This namespace provides functionality for logging HTTP content and headers transmitted between server and server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.MicrosoftExtensions.NamespaceDoc">
            <summary>
            This namespace provides interfaces required by Windows eplorer to read/write file attributes.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating server which supports used and free space reporting.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.NamespaceDoc">
            <summary>
            The ITHit.WebDav.Server.ResumableUpload namespace provides classes for handling resumable upload. You will use classes from this namespace to implement pause/resume/restore upload feature, upload process feature, upload via POST verb from AJAX client, non-cached upload in IIS.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.NamespaceDoc">
            <summary>
            This namespace provides interfaces for creating server which supports DASL server search.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.ISearch">
            <summary>
            Represents an item that supports search according to DASL standard.
            </summary>
            <remarks>
            <para>
            Implement this interface on folders that suppoort search. When search request is 
            recived the <see cref="T:ITHit.WebDAV.Server.DavEngine"/> calls <see cref="M:ITHit.WebDAV.Server.Search.ISearch.Search(System.String,ITHit.WebDAV.Server.Search.SearchOptions,System.Collections.Generic.List{ITHit.WebDAV.Server.PropertyName})"/> method.
            </para>
            <para>
            If this interface is found on folder items, your server will include <b>DASL: &lt;DAV:basicsearch&gt;</b> 
            header and <b>SEARCH</b> token in <b>Allow</b> header in response to <b>OPTIONS</b> requests. The WebDAV clients that support DASL 
            search, including IT Hit Ajax File Browser, may rely on this header and token to display search user interface.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ISearch.Search&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Search.ISearch.Search(System.String,ITHit.WebDAV.Server.Search.SearchOptions,System.Collections.Generic.List{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Returns a list of items that correspond to a search request. 
            </summary>
            <param name="searchString">A phrase to search.</param>
            <param name="options">Search parameters.</param>
            <param name="propNames">
            List of properties to retrieve with each item returned by this method. They will be requested by the 
            Engine in <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.GetProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},System.Boolean)"/> call.
            </param>
            <returns>List of <see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/> satisfying the search parameters or empty list.</returns>
            <remarks>
            <para>
            This method is called by <see cref="T:ITHit.WebDAV.Server.DavEngine"/> when client application is sending search request. 
            In your implementation you must return a list of items that correspond to the requested search phrase and options.
            </para>
            <para>The search phrase may contain wildcards:</para>
            <list type="bullet">
            <item><description>
            To indicate one or more characters the '%' is passed in search string.
            </description></item>
            <item><description>
            To indicate exactly one character the '_' is passed in search string.
            </description></item>
            </list>
            <para>To include '%', '_' and '\' characters in the search string thay are escaped with '\' character.</para>
            <para>Note that IT Hit Ajax File Browser is using '*' and '?' as wildcard characters. In case included in search they are replaced with '%' and '_'.</para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ISearch.Search&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">
            <summary>
            Indicates that an operation failed due to insufficient privileges for one or more items.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavException">
            <summary>
            Exception which can be thrown by WebDAV interface implementations.
            </summary>
            <remarks>
            There are some other exceptions derived from this one which contain specific
            fields, like <see cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException"/>.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor">
            <summary>
            Initializes a new instance of the DavException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message. 
            </summary>
            <param name="message">The message that describes the error. </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message and a
            reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference
            (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with serialized data. 
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the
            exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the
            source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or HResult is zero (0).</exception>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message, status
            code and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="innerException">The exception that is the cause of the current exception,
            or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message, details
            and status code.
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="errorDetails">XML element name and namespace which provides more specific information about
            error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.#ctor(System.String,System.Exception,ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with a specified error message,
            description, status code and a reference to the inner exception that is the cause of this exception. 
            </summary>
            <param name="message">The message that describes the error.</param>
            <param name="status"><see cref="T:ITHit.WebDAV.Server.DavStatus"/> instance that descrives the error.</param>
            <param name="innerException">The exception that is the cause of the current exception,
             or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
            <param name="errorDetails">XML element name and namespace which provides more specific information about
            error.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
            <param name="renderContent">Some methods, like "HEAD" forbid any content in response, this parameter will
            be <c>false</c> in this 
            case and nothing shall be written in the response.</param>
            <remarks>
            Full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.RenderInline(System.Xml.XmlWriter,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Writes exception as part of MultistatusException.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>        
            <remarks>        
            Only body shall be written. Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavException.CanGroupWith(ITHit.WebDAV.Server.DavException)">
            <summary>
            Determines whether two errors for different properties for the same item
            can be grouped into one as part of Multistatus response.
            </summary>
            <remarks>
            This method shall return true if both exceptions would produce the same output in <see cref="M:ITHit.WebDAV.Server.DavException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)"/>
            method not taking into account property name.
            </remarks>
            <param name="other">Exception to test.</param>
            <returns><c>true</c> if exceptions can be reported as one.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavException.ErrorDetails">
            <summary>
            Contains XML element name and namespace which will be written to the response body.
            It provides more information about error which can be interpreted by clients.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavException.Code">
            <summary>
            HTTP status code and description that will be sent to client.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the NeedPrivilegesException class.
            </summary>
            <param name="message">Error message.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.#ctor(System.String,System.String,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Initializes a new instance of the NeedPrivilegesException class.
            </summary>
            <param name="message">Error message.</param>
            <param name="path">Item path.</param>
            <param name="privilege">Missing privilege.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.AddRequiredPrivilege(System.String,ITHit.WebDAV.Server.Acl.Privilege)">
            <summary>
            Adds privilege that is required to perform the operation on the item.
            </summary>
            <param name="path">Item which misses the privilege.</param>
            <param name="privilege">Missing privilege.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
            <param name="renderContent">Whether contents shall be written to output.</param>
            <remarks>
            If exception is rendered 'inline', then it shall write only it's body.
            Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            Otherwise full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RenderInline(System.Xml.XmlWriter,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Renders exception as part of multistatus exception.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.CanGroupWith(ITHit.WebDAV.Server.DavException)">
            <summary>
            Determines whether two errors for different properties for the same item
            can be grouped into one as part of Multistatus response.
            </summary>
            <remarks>
            This method shall return true if both exceptions would produce the same output in
            <see cref="M:ITHit.WebDAV.Server.DavException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)"/> method not taking into account property name.
            </remarks>
            <param name="other">Exception to test.</param>
            <returns><c>true</c> if exceptions can be reported as one.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Acl.NeedPrivilegesException.RequiredPrivileges">
            <summary>
            List of &lt;item path, missing privilege> pairs.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.UpdateFileData(ITHit.WebDAV.Server.Extensibility.DavRequest,ITHit.WebDAV.Server.IContent,System.IO.Stream,System.Int64,System.String)">
            <summary>
            Returns true if file was updated completely (or last chunk written),
            so file can be automatically checked in.
            </summary>
            <param name="request"></param>
            <param name="file"></param>
            <param name="inputStream"></param>
            <param name="length"></param>
            <param name="contentType"></param>
            <returns></returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo">
            <summary>
            Information about file being uploaded.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.GetParent">
            <summary>
            Returns parent folder and name of the file.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.Name">
            <summary>
            Gets name of the file.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.Stream">
            <summary>
            Gets upload stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.ContentType">
            <summary>
            Gets file's content type.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.MethodHandlers.BaseUploadHandler.IUploadItemInfo.ContentLength">
            <summary>
            Gets content length.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.CancelUploadDavHandler">
            <summary>
            Summary description for CancelUploadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IisRequest">
            <summary>
            Represents an incoming HTTP request for IIS-hosted server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.DavRequest">
            <summary>
            Represents an incoming HTTP request.
            </summary>
            <remarks>
            <para>
            <see cref="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ClientLockTokens"/> property provides access to the lock tokens send by WebDAV client.
            Before modifying locked WebDAV Class 2 server items you must check if client provided necessary lock token.
            </para>
            <para>
            Usually you do not have to implement this class if you host your server in ASP.NET/IIS or in
            HttpListener as there are overloaded constructors of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> optimized for OWIN,
            for ASP.NET/IIS and for HttpListener.
            You can derive your class from this class if you host your server in any other environment
            and pass it to <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> constructor.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.RawUrl">
            <summary>
            Gets information about the URL of the current request.
            </summary>
            <value>
            Url, like /somefolder/?query
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.UrlPrefix">
            <summary>
            Gets concatenated request scheme, host and port, like: http://www.ithit.com:8080
            </summary>
            <value>
            Concatenated scheme, host and port.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ApplicationPath">
            <summary>
            Gets virtual application root path on the server.
            </summary>
            <value>
            The virtual path of the current application.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.HttpMethod">
            <summary>
            Gets the HTTP method specified by the client.
            </summary>
            <value>
            A <c>String</c> that contains the method used in the request.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.Headers">
            <summary>
            Gets a collection of HTTP headers.
            </summary>
            <value>
            A <c>NameValueCollection</c> of headers.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ContentType">
            <summary>
            Gets the MIME content type of the incoming request. 
            </summary>
            <value>
            A string representing the MIME content type of the incoming request, for example, "text/html". 
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ContentEncoding">
            <summary>
            Gets the character set of the entity-body.
            </summary>
            <value>
            An <c>Encoding</c> object representing the client's character set.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ContentLength">
            <summary>
            Specifies the length, in bytes, of content sent by the client.
            </summary>
            <value>
            The length, in bytes, of content sent by the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.InputStream">
            <summary>
            Gets the contents of the incoming HTTP entity body.
            </summary>
            <value>
            A <c>Stream</c> object representing the contents of the incoming HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.UserAgent">
            <summary>
            Gets the User-Agent header.
            </summary>
            <value>
            A <c>string</c> representing User-Agent header.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavRequest.ClientLockTokens">
            <summary>
            Gets a list of lock tokens submitted by client.
            </summary>
            <value>
            <c>StringCollection</c> object containing collection of lock tokens submitted by client.
            </value>
            <remarks>
            <c>ClientLockTokens</c> property provides access to the list of lock tokens 
            submitted by client. These lock tokens were generated during the call to your 
            <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Lock(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)"/> method implementation, associated with the item and returned to client. 
            When WebDAV client is modifying any server item it 
            sends back to server the list of lock tokens. In your WebDAV server Class 2 
            implementation before modifying any locked items you must check if WebDAV 
            client provided necessary lock token.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.IisResponse">
            <summary>
            Represents HTTP response for IIS-hosted server.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.DavResponse">
            <summary>
            Represents HTTP response.
            </summary>
            <remarks>
            <para>
            Usually you do not have to implement this interfaces if you host your server in ASP.NET/IIS or
            in HttpListener as <see cref="T:ITHit.WebDAV.Server.DavContextBase"></see> provides overloaded constructors optimized
            for OWIN, for ASP.NET/IIS and for HttpListener.
            You can implement this interface if you host your server  in any other environment
            and pass it to <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> constructor.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.DavResponse.AddHeader(System.String,System.String)">
            <summary>
            Adds the specified header and value to the HTTP headers for this response.
            </summary>
            <param name="name">
            The name of the HTTP header to set.
            </param>
            <param name="value">
            The value for the name header.
            </param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.DavResponse.Clear">
            <summary>
            Clears all content output from the buffer stream.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.StatusCode">
            <summary>
            Gets or sets the HTTP status code of the output returned to the client.
            </summary>
            <value>
            An Integer representing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.StatusDescription">
            <summary>
            Sets the HTTP status string of the output returned to the client.
            </summary>
            <value>
            A string describing the status of the HTTP output returned to the client.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentType">
            <summary>
            Sets the HTTP MIME type of the output stream.
            </summary>
            <value>
            The HTTP MIME type of the output stream.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentEncoding">
            <summary>
            Sets the HTTP character set of the output stream.
            </summary>
            <value>
            A <c>Encoding</c> object containing information about the character set of the current response.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentLength">
            <summary>
            Sets the content length of the output stream.
            </summary>
            <value>
            The value of the response's Content-Length header.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.OutputStream">
            <summary>
            Enables binary output to the outgoing HTTP content body.
            </summary>
            <value>
            An IO <see cref="T:System.IO.Stream"/> representing the raw contents of the outgoing HTTP content body.
            </value>
        </member>
        <member name="P:ITHit.WebDAV.Server.Extensibility.DavResponse.IsClientConnected">
            <summary>
            Gets a valus indicating whether client is still connected.
            </summary>
            <remarks>
            Most probably this property will be refreshed only when some data fails to send to client.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockResult">
            <summary>
            Result of <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Lock(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)"/> operation. 
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockResult.#ctor(System.String,System.TimeSpan)">
            <summary>
            Initializes a new instance of the LockResult class.
            </summary>
            <param name="token">Lock token associated with a lock.</param>
            <param name="timeOut">Timeout value. <c>TimeSpan.MaxValue</c> means 'never'.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockResult.Token">
            <summary>
            Gets/sets lock token associated with the lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockResult.TimeOut">
            <summary>
            Gets/Sets timeout value;
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.PropertyName">
            <summary>
            Describes property name.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.VERSION_NAME">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionName"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ACL">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/> / <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.SetAcl(System.Collections.Generic.IList{ITHit.WebDAV.Server.Acl.WriteAce})"/>.
            </summary>        
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ACL_RESTRICTIONS">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetAclRestrictions"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.ALTERNATE_URI_SET">
            <summary>
            Is not supported.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETETAG">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.IContent.Etag"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.COMMENT">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.GetComment"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CREATIONDATE">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Created"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CREATOR_DISPLAYNAME">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.GetCreatorDisplayName"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CURRENT_USER_PRIVILEGE_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetCurrentUserPrivilegeSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.DISPLAYNAME">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTLANGUAGE">
            <summary>
            Not currently implemented.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTLENGTH">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.IContent.ContentLength"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETCONTENTTYPE">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.IContent.ContentType"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GETLASTMODIFIED">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Modified"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetGroup"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP_MEMBER_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipal.GetGroupMembers"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.GROUP_MEMBERSHIP">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IPrincipal.GetGroupMembership"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.INHERITED_ACL_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetInheritedAclSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.LOCKDISCOVERY">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Class2.ILock.GetActiveLocks"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.OWNER">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetOwner"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.PRINCIPAL_COLLECTION_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetPrincipalCollectionSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.PRINCIPAL_URL">
            <summary>
            Is not directly supported. Is the same as <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Path"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.SUPPORTED_PRIVILEDGE_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetSupportedPrivilegeSet"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.AUTO_VERSION">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.GetAutoVersion"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.VERSION_HISTORY">
            <summary>
            Refers to <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.SUPPORTED_PRIVILEGE_SET">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetSupportedPrivilegeSet"/>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.CURRENT_USER_PRINCIPAL">
            <summary>
            Refers to <see cref="!:IAclHierarchyItem.GetCurrentUserPrincipal"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.QUOTA_USED_BYTES">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Quota.IQuota.GetUsedBytes"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.PropertyName.QUOTA_AVAILABLE_BYTES">
            <summary>
            Refers to <see cref="M:ITHit.WebDAV.Server.Quota.IQuota.GetAvailableBytes"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property local name.</param>
            <param name="propNamespace">Property namespace.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.ToString">
            <summary>
            Returns property name as string.
            </summary>
            <returns>String representation.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.Equals(ITHit.WebDAV.Server.PropertyName)">
            <summary>
            Determines if two property names are equal.
            </summary>
            <param name="other"><see cref="T:ITHit.WebDAV.Server.PropertyName"/> to compare to.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.op_Equality(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.PropertyName)">
            <summary>
             Equality operator.
            </summary>
            <param name="name1">First name.</param>
            <param name="name2">Second name.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.op_Inequality(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.PropertyName)">
            <summary>
             Unequality operator.
            </summary>
            <param name="name1">First name.</param>
            <param name="name2">Second name.</param>
            <returns><c>true</c> if property names are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.Equals(System.Object)">
            <summary>
            Determines if two property names are equal.
            </summary>
            <param name="obj"><see cref="T:ITHit.WebDAV.Server.PropertyName"/> to compare to.</param>
            <returns><c>true</c> if property names are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyName.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>       
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>        
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Namespace">
            <summary>
            Property namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyName.Name">
            <summary>
            Property local name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.PostUploadProgressModule">
            <summary>
            Enables POST upload with progress of files to IIS/ASP.NET.
            </summary>
            <remarks>
            <para>
            You need to use this module if you are using AJAX File Browser with Internet Explorer 9 and earlier.
            </para>
            </remarks>
            <example>
                Example of configuration for IIS:
            <code>
            <![CDATA[
                <httpModules>
                    <remove name="FileAuthorization"/>
                    <add 
                        name="PostUploadProgressModule"
                        type="ITHit.WebDAV.Server.PostUploadProgressModule, ITHit.WebDAV.Server" />
                </httpModules>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.PostUploadProgressModule.Init(System.Web.HttpApplication)">
            <summary>
            Initializes a module and prepares it to handle requests.
            </summary>
            <param name="context">An <see cref="T:System.Web.HttpApplication"></see> that provides access to the
             methods, properties, and events common to all application objects within an ASP.NET application </param>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.PostUploadProgressModule.Dispose">
            <summary>
            Disposes of the files (other than memory) used by the module that implements
            <see cref="T:System.Web.IHttpModule"></see>.
            </summary>
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress">
             <summary>
             Implemented on files and folders to report upload progress.
             </summary>
             <remarks>
             <para>This interface should be implemented on files that can provide upload progress information to client
             application. Optionally it can be implemented on folder items.</para>
             <para>When implementing this interface you may need to configure <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> and 
             <see cref="T:ITHit.WebDAV.Server.PostUploadProgressModule"/> module in your web.config file if your WebDAV server is hosted in IIS/ASP.NET.</para>
             <para>
             Usually client application requests upload progress in following cases: 
             <list type="bullet">
             <item><description>If connection was broken (paused) and client would like to restore upload. Client will
             submit upload-progress request to get number of bytes successfully saved on server side and will start the
             upload from the next byte. You must add <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> in your web.config to support this 
             scenario if your application is running ASP.NET 2.0 pool. The <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> is 
             not required if you are using ASP.NET 4.0 pool and is ignored if you include it in web.config</description></item>
             <item><description>When client application requires information about how much of the uploaded file
             was processed on server side. Usually this is required by Microsoft Internet Explorer 9 and earlier only.  
             IE 9 and earlier does not have any information about how much of the file was submitted to server. 
             It will submit upload-progress request to update its upload progress bar from time to time. You must 
             add <see cref="T:ITHit.WebDAV.Server.PostUploadProgressModule"/> in your web.config to support this scenario.</description></item>
             </list>
             </para>
             <para>
             To check if folder or file supports upload-progress report and resumable upload feature the client application
             will submit OPTIONS request to that item. If the item implements <c>IUploadProgress</c> interface Engine will
             add 'resumable-upload' token to DAV response header. See example below.
             </para>
             <para>
             To get information about file upload progress client will submit REPORT request to that file with upload
             progress type. The Engine will call <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress"/> method in this case. You will return an
             <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains single item (this file implementing <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload"/>) from
             <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress"/> method implementation. The engine will extract necessary info from the
             returned <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload"/> interface and return it to client. The response will contain XML
              with information about upload progress for the requested file: url of the file, number or bytes uploaded,
             total size of the file and time when last save operation occurred. 
             </para>
             <para>The response returned by server Engine to client is a REPORT multistatus response that contains three
             properties for each file:
             </para>
             <para>
             <list type="bullet">
             <item> <description><b>ithit:bytes-uploaded</b> - integer value. Number of bytes uploaded and saved in
             persistent storage. If upload was broken or paused the client application will usually start upload from the
             next byte returned in this property.</description></item>
             <item> <description><b>ithit:last-chunk-saved</b> - date\timein in RFC 1123 format. Indicates when last chunk
             was saved. May be used in admin applications and automatic maintenance tools to remove files that were not
             fully uploaded.</description></item>
             <item> <description><b>ithit:total-content-length</b> - integer value. Total file size that is being uploaded
             to server. Thin client applications may use this value for displaying upload progress.</description></item>
             </list>
             </para>
             <para>See example of upload progress report below.</para>
             <para>
             The client application can also submit upload-progress REPORT request to a folder. In this case from your
             <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress"/> property implementation you will return IEnumerable containing files that are being uploaded
             that reside in the folder's subtree. The response XML will contain info about each file from the <see cref="T:System.Collections.Generic.IEnumerable`1"/> in a
             separate response tag. See example below.
             </para>
             <para>
             If item does not support upload-progress report and server is based on IT Hit WebDAV Server Engine the server
             will respond with '403 Forbidden' to
             REPORT request. The body will contain &lt;A:supported-report xmlns="DAV:"/&gt;  element. If server does not support
             REPORT verb you will get 405 Method Not Allowed response.
             </para>
             </remarks>
             <example>
             <para>
             OPTIONS request is used to determine if folder or file supports resumable upload.
             <para>Request:</para>
             <code>
             <![CDATA[
             OPTIONS /Folder/ HTTP/1.1
             Host: davserver
             Content-Length: 0
             ]]>
             </code>
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 200 OK
             Content-Length: 0
             Accept-Ranges: none
             DAV: 1, 2, resumable-upload
             Public: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             Allow: OPTIONS, PROPFIND, PROPPATCH, COPY, MOVE, DELETE, MKCOL, LOCK, UNLOCK
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over file contains  info about single item.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: application/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:">
             <D:response>
                <D:href>http://server:8580/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>    
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>        
             </D:response>        
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             Upload progress report submitted over folder contains  info about all files being uploaded to subtree.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /folder HTTP/1.1
             Host: http://server:8580/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>
             
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 207 Multi-Status
             Content-Length: 2452
             Content-Type: application/xml;charset=UTF-8
            
             <?xml version="1.0" encoding="utf-8" ?>
             <D:multistatus xmlns:D="DAV:" xmlns:ithit="ithit">
             <D:response>
                <D:href>http://server:8580/folder/LargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>20</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:29:43 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>150742</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>
             </D:response>
             <D:response>
                <D:href>http://server:8580/folder/nestedfolder/AnotherLargeFile.doc</D:href>
                <D:propstat>
                    <D:prop>
                         <ithit:bytes-uploaded>47</ithit:bytes-uploaded>
                         <ithit:last-chunk-saved>Wed, 23 May 2007 13:16:12 GMT</ithit:last-chunk-saved>
                         <ithit:total-content-length>6398</ithit:total-content-length>
                   </D:prop>
                   <D:status>HTTP/1.1 200 OK</D:status>
                </D:propstat>
             </D:response>
            </D:multistatus>
             ]]>
             </code>
             </para>
             <para>
             If item on server based on IT Hit WebDAV Server Engine does not support upload-progress the server will respond
             with 403 Forbidden response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 403 Forbidden
             Content-Length: 31
             Content-Type: application/xml;charset=UTF-8
            
             <supported-report xmlns="DAV"/>
             ]]>
             </code>
             </para>
             <para>
             If server does not support REPORT verb (often non-IT Hit Engine) you will get 405 Method Not Allowed response.
             <para>Request:</para>
             <code>
             <![CDATA[
             REPORT /LargeFile.doc HTTP/1.1
             Host: http://davserver/
             Content-Type: application/xml; charset=\"utf-8\"
             Content-length: 32
             
             <upload-progress xmlns='ithit'/>
             ]]>
             </code>  
             Response:
             <code>
             <![CDATA[
             HTTP/1.1 405 Method Not Allowed
             Content-Length: 0
             Content-Type: application/xml;charset=UTF-8
            
             ]]>
             </code>
             </para>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress">
            <summary>Gets IEnumerable with items that are being uploaded to this item subtree.</summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            Returns <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a single item if implemented on file items. Return all items that are being uploaded to
            this subtree if implemented on folder items.
            </para>
            <para>
            Engine calls <see cref="P:ITHit.WebDAV.Server.IHierarchyItem.Path"/>, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.LastChunkSaved"/>, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.BytesUploaded"/>, 
            <see cref="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.TotalContentLength"/> and returns this information to
            client.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IUploadProgress.GetUploadProgress&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule">
            <summary>
            Enables non-cached upload of files to IIS/ASP.NET.
            </summary>
            <remarks>
            <para>
            Always use this module if you implement resumable upload features and your WebDAV server is hosted in 
            application that uses ASP.NET 2.0 pool. It is recommended to enable this module even if you do not need any resumable upload fetures but 
            host your server is using ASP.NET 2.0 pool. This module is not required for application running in ASP.NET 4.0 pool or later and is ignored if enabled.
            </para>
            <para>
            Without this module when a file is being uploaded to the server running as ASP.NET application with 2.0 pool, the file 
            will be first saved to temporary upload folder. Only when entire file is uploaded it becomes available for .NET
            user code. <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> eliminates this 
            problem passing file content directly to Engine. This problem is specific to ASP.NET/IIS and you do not need 
            this module when creating HttpListener-based server or if you are using ASP.NET 4.0 pool.
            </para>
            <para>
            <b>Note</b>: Always use <see cref="M:ITHit.WebDAV.Server.DavContextBase.#ctor(System.Web.HttpContext)"/> overloaded constructor when utilizing 
            this module.
            </para>
            </remarks>
            <example>
            <para>Example of configuraiton for IIS 8 integrated mode and IIS 7.x integrated mode:</para>
            <code>
            <![CDATA[
            <system.webServer>
                <modules>
                    <add 
                        name="PutUploadProgressAndResumeModule"
                        type="ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule, ITHit.WebDAV.Server"
                        preCondition="integratedMode" />
                </modules>
            </system.webServer>
             ]]>
            </code>
            </example>
            <example>
                Example of configuration for IIS 8 classic mode, IIS 7.x classic mode, IIS 6 and IIS 5.1:
            <code>
            <![CDATA[
            <system.web>
                <httpModules>
                    <remove name="FileAuthorization"/>
                    <add 
                        name="PutUploadProgressAndResumeModule"
                        type="ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule, ITHit.WebDAV.Server" />
                </httpModules>
            </system.web>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule.Init(System.Web.HttpApplication)">
            <summary>
            Initializes a module and prepares it to handle requests.
            </summary>
            <param name="context">An <see cref="T:System.Web.HttpApplication"></see> that provides access to the
            methods, properties, and events common to all application objects within an ASP.NET application </param>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule.Dispose">
            <summary>
            Disposes of the files (other than memory) used by the module that implements 
            <see cref="T:System.Web.IHttpModule"/>.
            </summary>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.PostReader.ReadTillSeparatorInChunks(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Boolean)">
            <summary>
            After this method <see cref="F:ITHit.WebDAV.Server.Impl.ResumableUpload.PostReader.readCachedData"/> contains cached data right after next boundary.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext">
            <summary>
            Contains stream of data in case of POST and PUT when <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> is used.
            </summary>
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext.GetStream">
            <summary>
            Returns content stream of current request.
            </summary>
            <returns>Content stream.</returns>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext.IsAvailable">
            <summary>
            Determines if <see cref="T:ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule"/> is used and <see cref="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadContext.GetStream"/>
            method can be called.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.#ctor(System.Web.HttpWorkerRequest)">
            <summary>   
            Constructor.   
            </summary>   
            <param name="request">The original worker request.</param>           
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.ReadEntityBody(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetTotalEntityBodyLength">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBody(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBody">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUriPath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetQueryString">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRawUrl">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetHttpVerbName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetHttpVersion">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRemoteAddress">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRemotePort">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetLocalAddress">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetLocalPort">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPreloadedEntityBodyLength">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.ReadEntityBody(System.Byte[],System.Int32,System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetKnownRequestHeader(System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetAppPathTranslated">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendStatus(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendKnownResponseHeader(System.Int32,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendUnknownResponseHeader(System.String,System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromMemory(System.Byte[],System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromFile(System.String,System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromFile(System.IntPtr,System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.FlushResponse(System.Boolean)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.EndOfRequest">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.IsEntireEntityBodyIsPreloaded">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.CloseConnection">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetQueryStringRawBytes">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRemoteName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetServerName">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetConnectionID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUrlContextID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetAppPoolID">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetRequestReason">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUserToken">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetVirtualPathToken">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.IsSecure">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetProtocol">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetFilePath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetFilePathTranslated">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetPathInfo">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetAppPath">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUnknownRequestHeader(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetUnknownRequestHeaders">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetServerVariable(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetBytesRead">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.MapPath(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendResponseFromMemory(System.IntPtr,System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SetEndOfSendNotification(System.Web.HttpWorkerRequest.EndOfSendNotification,System.Object)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendCalculatedContentLength(System.Int32)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.SendCalculatedContentLength(System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.HeadersSent">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.IsClientConnected">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificate">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateValidFrom">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateValidUntil">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateBinaryIssuer">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificateEncoding">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.GetClientCertificatePublicKey">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.ToString">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.MachineConfigPath">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.RootWebConfigPath">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.MachineInstallDirectory">
            <exclude/>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.ResumableUpload.UploadWorkerRequest.RequestTraceIdentifier">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Deltav">
            <summary>
            DeltaV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Deltav.PropertyNames">
            <summary>
            DeltaV Live Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.AutoVersion">
            <summary>
            Auto versioning modes supported by item to be used with versioning unaware clients.
            </summary>
            <remarks>
            <para>
            This enumeration determines how engine responds to WebDAV client requests that attempt to modify 
            checked-in items content or properties. Each item that support versioning can function in one of the following 
            auto-versioning modes:
            </para>
            <para>
            <b>NoAutoVersioning Mode.</b>
            In this mode item must be checked-out before modifications. Clients that does not support DeltaV will not be
            able to modify checked-in items.
            </para>
            <para>
            <b>CheckOutCheckIn Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. Potentially many
            versions may be created. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
            <list type="bullet">
            <item><description>Auto check-out performed.</description></item>
            <item><description>Modifications performed.</description></item>
            <item><description>Auto check-in performed.</description></item>
            </list>
            </description></item>
            <item><description>Unlock request (optional).</description></item>
            </list>
            </para>
            <para>
            <b>CheckOutUnlockedCheckIn Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. If WebDAV client
            locks the item prior to update, the item will be checked in during unlock. This mode reduces the number of
            versions created by versioning unaware clients. The item is never left checked-out. This mode is recommended if
            you need to support both Class 1 and Class 2 WebDAV clients. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
            <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                <item><description>Auto check-in performed if item not locked.</description></item>
            </list>
            </description></item>
            <item><description>Unlock request (optional).
            <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
            </list>
            </description></item>
            </list>
            </para>
            <para>
            <b>CheckOut Mode.</b>
            In this mode any WebDAV client applications will be able to modify checked-in items on server. If the item 
            was not locked before the update it will be left in checked-out state after modifications. Workflow for
            versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (optional).</description></item>
            <item><description>Modification request: 
                <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                </list>
            </description></item>
            <item><description>Unlock request (optional). 
                <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
                </list>
            </description></item>
            </list>
            </para>
            <para>
            <b>LockedCheckOut Mode.</b>
            Only WebDAV client applications that lock item before the update will be able to modify checked-in item. 
            This mode minimizes amount of versions created by versioning unaware clients. Class 1 WebDAV applications will 
            not be able to modify checked-in items. Workflow for versioning-unaware WebDAV client:
            <list type="number">
            <item><description>Lock request (required).</description></item>
            <item><description>Modification request: 
                <list type="bullet">
                <item><description>Auto check-out performed.</description></item>
                <item><description>Modifications performed.</description></item>
                </list>
            </description></item>
            <item><description>Unlock request (required). 
                <list type="bullet">
                <item><description>Check-in performed.</description></item>
                <item><description>Unlock performed.</description></item>
                </list>
            </description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.NoAutoVersioning">
            <summary>
            Auto versioning is not supported for checked-in items. Modification requests of versioning unaware clients
            will fail if item was not checked-out.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutCheckIn">
            <summary>
            Before any item modification (such as changing content or properties) 
            by versioning unaware client  engine will call <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/>. After the item is
            modified <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> will be called.
            <para>
            This potentially can create a lot of versions.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOutUnlockedCheckIn">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/>. If item is not locked engine
            will call <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> when modification completes.
            <para>
            If item is locked, <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> will be called before the
            <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/>. If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.CheckOut">
            <summary>
            If client tries to modify checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/>. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> will not be called.
            <para>
            If item is locked, <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> will be called before the
            <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/>. If lock expires you must check-in item manually.
            </para>
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DeltaV.AutoVersion.LockedCheckOut">
            <summary>
            If client tries to modify locked checked-in item, engine will automatically call
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/>.
            <para>
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> will be called before the <see cref="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)"/>.
            If lock expires you must check-in item manually.
            </para>
            <para>
            If item is not locked - update request will fail.
            </para>
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItem">
            <summary>
            Base interface for items that support versioning and item versions (DeltaV items).
            </summary>
            <remarks>
            This interface defines properties common to all items that support versioning and item versions. 
            It provides the means of getting and setting comments and author name when creating new version. 
            The author of the version is set and get via <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.SetCreatorDisplayName(System.String)"/>,
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.GetCreatorDisplayName"/>methods and comment via <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.GetComment"/>,
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.SetComment(System.String)"/> methods.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.SetComment(System.String)">
            <summary>
            Sets a brief comment about a file that is suitable for presentation to a user.
            </summary>
            <returns>
            .
            </returns>
            <param name="comment">Comment string.</param>
            <remarks>
            Comment can be used to indicate why that version was created.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItem.SetComment&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.GetComment">
            <summary>
            Retrieves a brief comment about a file that is suitable for presentation to a user.
            </summary>
            <remarks>
            Comment can be used to indicate why that version was created.
            </remarks>
            <returns>Comment string.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItem.GetComment&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.SetCreatorDisplayName(System.String)">
            <summary>
            Sets display name of the user that created this item.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            Sets description of the creator of the file that is
            suitable for presentation to a user. Can be used to indicate who created that version.
            </remarks>
            <param name="creatorDisplayName">String representing author name.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItem.SetCreatorDisplayName&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IDeltaVItem.GetCreatorDisplayName">
            <summary>
            Retrieves display name of the user that created this item.
            </summary>
            <remarks>
            Retrieves description of the creator of the file that is
            suitable for presentation to a user. Can be used to indicate who created that version.
            </remarks>
            <returns>String representing author name.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IDeltaVItem.GetCreatorDisplayName&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IHistory">
            <summary>
            Contains all versions of a particular version-controlled item.
            </summary>
            <remarks>
            The important property of this interface is <see cref="T:System.IO.Path"/> property inherited from IHierarchyItem. 
            The url returned by this property is used by client applications to remove item from version control. 
            The client application submits DELETE WebDAV request to this url and the engine calls
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> 
            passing <b>false</b> as a parameter. In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> you will
            usually delete all versions. 
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistory.GetCurrentVersion">
            <summary>
            Retrieves current item version.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IHistory.GetCurrentVersion&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistory.GetVersionSet(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})">
            <summary>
            Retrieves all versions of current item.
            </summary>
            <returns>
            .
            </returns>
            <param name="propNames">Names of properties which engine will request from the returned items.</param>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IHistory.GetVersionSet&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IHistory.GetRootVersion">
            <summary>
            Retrieves item's root version.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IHistory.GetRootVersion&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersion">
            <summary>
            Represents single item version.
            </summary>
            <remarks>
            <para>
            Defines the properties and methods that item version must implement. In addition to methods and properties
            provided by <see cref="T:ITHit.WebDAV.Server.DeltaV.IDeltaVItem"/> this interface also provides methods for getting version name, next
            version and previous version. 
            </para>
            <para>
            Usually you will implement <b>IVersion</b> interface for your file version objects together with
            <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/> interface. While <b>IFile</b> interface is optional for file versions it may be useful if
            your DeltaV client application will request content of the file version. In this case 
            <see cref="M:ITHit.WebDAV.Server.IContent.Read(System.IO.Stream,System.Int64,System.Int64)"/>, <see cref="P:ITHit.WebDAV.Server.IContent.ContentLength"/> and <see cref="P:ITHit.WebDAV.Server.IContent.ContentType"/> 
            members of the <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/> interface will be requested by the engine. Copying, moving, updating 
            properties and content is not allowed for a version, your <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.CopyTo(ITHit.WebDAV.Server.IItemCollection,System.String,System.Boolean,ITHit.WebDAV.Server.MultistatusException)"/>, 
            <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.MoveTo(ITHit.WebDAV.Server.IItemCollection,System.String,ITHit.WebDAV.Server.MultistatusException)"/>, <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/> and
            <see cref="M:ITHit.WebDAV.Server.IContent.Write(System.IO.Stream,System.String,System.Int64,System.Int64)"/> implementations must throw <see cref="T:ITHit.WebDAV.Server.DavException"/> with status 
            <see cref="F:ITHit.WebDAV.Server.DavStatus.NOT_ALLOWED"/>.
            </para>
            <para>
            Generally from your <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionName"/> implementation you can return any string suitable for 
            displaying to user as a version or the hierarchy item. This string must be unique among versions for this 
            hierarchy item. Usually you will return “1”, “2”, etc or “3.1”, “3.4”, etc. 
            </para>
            <para>
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersion.GetSuccessor"/> and <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersion.GetPredecessor"/> methods of this interface return next and previous
            version for the item. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersion.GetVersionableItem"/> method returns the hierarchy item (usually file) to
            which this version belongs.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersion.GetSuccessor">
            <summary>
            Next version or null if no next version exists.
            </summary>
            <returns>Version item representing next version
             in the list of versions or null if no next version exists.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersion.GetSuccessor&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersion.GetPredecessor">
            <summary>
            Previous version or null if no previous version exists.
            </summary>
            <returns>Version item representing previous version in the list of versions or null if no previous version
            exists.</returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersion.GetPredecessor&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersion.GetVersionableItem">
            <summary>
            Hierarchy item for this version.
            </summary>
            <returns>
            .
            </returns>
            <value>Hierarchy item for this version.</value>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersion.GetVersionableItem&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersion.VersionName">
            <summary>
            Name of the version.
            </summary>
            <value>Name of the version.</value>
            <remarks>
            Must be unique among version items for a given hierarchy item. This string is intended for display
            for a user.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersion.VersionName&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.DeltaV.IVersionableItem">
            <summary>
            This interface must be implemented on items that support versioning.
            </summary>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version control
            engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method passing <b>true</b> as a parameter.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> implementation you must create a new version. The content and
            properties of the new version must be copied from this item. After the call to 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must point to the object 
            implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistory"/> interface that will contain single version. The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.IsCheckedOut"/> 
            property must return <b>false</b>.
            </para>
            <para>
            <b>If item is under version control it mast always have at last one version in its versions list.</b>
            </para>
            <para>
            After the item had been put under version control client can issue checkout command.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/> implementation you will mark item as checked-out and allow item modifications.
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            <para>
            Finally client issues check-in command or discards changes issuing uncheck-out command.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> implementation you will create a new version. The content and properties of the
            new version must be copied from this item. The item must be marked as checked-in.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/> implementation you will discard changes and restore pre-checkout state.
            Content and properties must be copied from current version to this item. The item must be marked as checked-in.
            </para>
            <para>
            The typical versioning workflow:
            <list type="number">
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/>. Create new version,
            copy content and properties from this item to new version.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/>.
            Mark item as checked-out.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.IContent.Write(System.IO.Stream,System.String,System.Int64,System.Int64)"/> or <see cref="M:ITHit.WebDAV.Server.IHierarchyItem.UpdateProperties(System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyValue},System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName},ITHit.WebDAV.Server.MultistatusException)"/>.
            Modify item content and properties.</description></item>
            <item><description>Engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> or
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/>. For <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> - create new version, copy content and
            properties from this item to new version. For <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/> - copy content and properties from
            current version to this item. Mark item as checked-in.</description></item>
            </list>
            </para>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> implementation you will create a new version and copy content and
            properties from <see cref="T:ITHit.WebDAV.Server.DeltaV.IVersion"/> passed as a parameter to new version. You will also replace content and
            properties of this item. The new created version becomes current version. The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> 
            method can only be called when item is in check-in state.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method
            passing <b>false</b> as a parameter. In your implementation you will usually delete all versions.
            <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must return <b>null</b> after this call.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn">
            <summary>
            Creates new version. Copies all properties and content from this item.
            </summary>        
            <returns>
            Url of the newly created version.
            </returns>
            <remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <para>
            In your implementation you must create a new version. The content and properties of the new version must be
            copied from this item. 
            </para>
            <para>
            After the call to this method method <see cref="M:ITHit.WebDAV.Server.DeltaV.IHistory.GetCurrentVersion"/> must return the
            created version.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.CheckIn&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)">
            <summary>
            Allow modifications to the content and properties of this version-controlled item.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckOut(System.Boolean)"/> implementation you will mark item as checked-out and allow item
            modifications. 
            When item is in check-out state WebDAV client can issue commands updating item contents and properties.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.CheckOut&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut">
            <summary>
            Cancels the checkout and restores the pre-checkout state of the version-controlled item.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UnCheckOut"/> implementation you will discard changes and restore pre-checkout state. 
            Content and properties must be copied from current version to this item. The item must be marked as
            checked-in.
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.UnCheckOut&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)">
            <summary>
            Updates content and properties of the item to those identified by <paramref name="version"/> parameter.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> implementation you will create a new version and copy content and 
            properties from <see cref="T:ITHit.WebDAV.Server.DeltaV.IVersion"/> passed as a parameter to new version. You will also replace content 
            and properties of this item. The new created version becomes current version. 
            </para>
            <para>
            The <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.UpdateToVersion(ITHit.WebDAV.Server.DeltaV.IVersion)"/> method can only be called when item is in check-in state.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.UpdateToVersion&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.SetAutoVersion(ITHit.WebDAV.Server.DeltaV.AutoVersion)">
            <summary>
            Sets property which determines how checked-in item responds to
            WebDAV client attempts to modify its content or properties.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>        
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion"/> enum values.</value>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.SetAutoVersion&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.GetAutoVersion">
            <summary>
            Retrieves property which determines how checked-in item responds to WebDAV
            client attempts to modify its content or properties.
            </summary>
            <returns>
            .
            </returns>
            <value>One of <see cref="T:ITHit.WebDAV.Server.DeltaV.AutoVersion"/> enum values.</value>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.GetAutoVersion&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)">
            <summary>
            Puts or removes current item from version control.
            </summary>
            <returns>
            .
            </returns>
            <remarks>
            <para>
            By default items in the repository are not under version control. When item is being put under version
            control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method passing <b>true</b> as a parameter.
            In your <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> implementation you must create a new version.
            The content and properties of the new version must be copied from this item. After the call to 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must point to the object 
            implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistory"/> interface that will contain single version.
            The <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.IsCheckedOut"/> property must return <b>false</b>;
            </para>
            <para><b>If item is under version control it mast always have at last one version in its
            versions list.</b></para>
            <para>
            If <see cref="P:ITHit.WebDAV.Server.DavEngine.AutoPutUnderVersionControl"/> is <b>true</b> and item is not under version control
            prior to any item content or properties update <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/>
            will be called.
            </para>
            <para>
            When item is being removed from version control engine calls <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> method
            passing <b>false</b> as a parameter. In your implementation you will usually delete all versions.
            <see cref="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory"/> property must return <b>null</b> after this call.
            </para>
            </remarks>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.PutUnderVersionControl&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.VersionHistory">
            <summary>
            Current item version history. Null, if item is not under version control.
            </summary>
            <value>
            Item implementing <see cref="T:ITHit.WebDAV.Server.DeltaV.IHistory"/> interface or null if item is not under version control.
            </value>
            <remarks>If item is under version control it always has at last
            one version in its versions list. This property is used for precondition checking and shall not throw
            exceptions.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.VersionHistory&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.IsCheckedOut">
            <summary>
            Gets a value indicating whether the item is in checked-in or checked-out state.
            </summary>
            <value>
            Boolean value indicating if item is in checked-out state.
            </value>
            <remarks>
            This property is used for precondition checking and shall not throw exceptions.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.IsCheckedOut&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DeltaV.IVersionableItem.IsAutoCheckedOut">
            <summary>
            Gets a value indicating whether the item was check-out automatically by engine without
            explicit request from client.
            </summary>
            <remarks>
            Before checking-out the engine sets this property.
            When item is being unlocked engine reads this property and calls 
            <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.CheckIn"/> if necessary. This property is required for auto-versioning.
            This property shall not throw exceptions.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IVersionableItem.IsAutoCheckedOut&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavEngine">
            <summary>
            The DavEngine class provides the core implementation for WebDAV engine.
            </summary>
            <remarks>
            <para>Engine parses XML send by WebDAV client, processes requests making calls to your implementations of 
            WebDAV interfaces (<see cref="T:ITHit.WebDAV.Server.IHierarchyItem"/>, <see cref="T:ITHit.WebDAV.Server.Class1.IFolder"/>, <see cref="T:ITHit.WebDAV.Server.Class1.IFile"/> and other) 
            and finally generates XML response.
            </para>
            <para>
            In each HTTP request you will create separate instance of your class derived 
            from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class and pass it to the <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> method. Via the context, engine 
            receives all necessary information about hosting environment.
            </para>     
            <para>
            You must set <see cref="P:ITHit.WebDAV.Server.DavEngine.License"/> property before you can use the engine.
            </para>
            <para>
            All updates invoked within one request execution shall be inside one transactions.
            Transaction can be committed or rollbacked in <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> method, which
            is called right before starting sending response to client.
            After this method is called, no methods of interfaces which update state will be called. However methods
            which read state can be called.
            </para>
            </remarks>
            <threadsafety>Method <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> is threadsafe. All other members are not threadsafe.
            You can create a single instance of DavEngine, initialize it onces and use to serve all requests 
            from different threads.</threadsafety>
            <example>
      <para>The code below is part of 'WebDAVServer.NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private readonly string license = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");

    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public override bool IsReusable
    {
        get { return true; }
    }
  

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngineAsync engine = getOrInitializeEngine(context);

        context.Response.BufferOutput = false;
        DavContext ntfsDavContext = new DavContext(context);
        await engine.RunAsync(ntfsDavContext);
    }

    private DavEngineAsync initializeEngine(HttpContext context)
    {

        ILogger logger = Logger.Instance;
        var engine = new DavEngineAsync
        {
            Logger = logger

            // Use idented responses if debug logging is enabled.
            , OutputXmlFormatting = debugLoggingEnabled ? Formatting.Indented : Formatting.None
        };

        engine.License = license;

        return engine;
    }

    private DavEngineAsync getOrInitializeEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeEngine(context);
        }

        return (DavEngineAsync)context.Application[ENGINE_KEY];
    }
}
]]></code>
    </example>
            <example>
            <para>HttpListener-based server:</para>
            <code>
            class Program
            {
                static void Main(string[] args)
                {
                    HttpListener listener = new HttpListener();
                    listener.Prefixes.Add("http://localhost:8080/");
                    listener.Start();
                    DavEngine engine = new DavEngine();
                    engine.License = "..."; 
                    while (true)
                    {
                        HttpListenerContext context = listener.GetContext();
                        engine.Run(new MyContext(context, listener.Prefixes));
                        try
                        {
                            context.Response.Close();
                        }
                        catch
                        {
                            // client closed connection before the content was sent
                        }
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.#ctor">
            <summary>
            Initializes a new instance of the DavEngine class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.RegisterMethodHandler(System.String,ITHit.WebDAV.Server.Extensibility.IMethodHandler)">
            <summary>
            Registers custom method handler.
            </summary>
            <param name="method">HTTP verb.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IMethodHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom method handler to be called by the engine.
            If the handler for the specified method was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
            <example>
            <code>
            <![CDATA[
               DavEngine engine = new DavEngine();
               MyCustomGetHandler handler = new MyCustomGetHandler();
               handler.OriginalHandler = engine.RegisterMethodHandler("GET", handler);
            
               MyDavContext context = new MyDavContext(...);
               engine.Run(context);
            ]]>
            </code>
            </example>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;IMethodHandler&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.RegisterPropertyHandler(ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.Extensibility.IPropertyHandler)">
            <summary>
            Registers custom property handler.
            </summary>
            <param name="propName">Property name.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IPropertyHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Property handler allows formatting of property values to XML and reading property values from XML.
            Using this method you can register custom property handler to be called by the engine.
            If the handler for the specified property was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.RegisterOptionsHandler(System.String,ITHit.WebDAV.Server.Extensibility.IOptionsHandler)">
            <summary>
            Registers custom options handler.
            </summary>
            <param name="name">Token that will be added to 'DAV' header for OPTIONS response.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IOptionsHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom options handler to be called by the engine.
            If the handler for the specified token was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.RegisterReportHandler(System.String,System.String,ITHit.WebDAV.Server.Extensibility.IReportHandler)">
            <summary>
            Registers custom report handler.
            </summary>
            <param name="name">Report element name.</param>
            <param name="namespace">Report namespace.</param>
            <param name="handler">Custom handled implementing <see cref="T:ITHit.WebDAV.Server.Extensibility.IReportHandler"/> interface.</param>
            <returns>Original handler if any.</returns>
            <remarks>
            Using this method you can register custom report handler to be called by the engine.
            If the handler for the specified token was already defined it is returned from this method.
            The original handler can be saved and called later from your custom handler.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Processes WebDAV request and generates WebDAV response.
            </summary>
            <param name="context">
            Instance of your context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class.
            </param>
            <returns> .</returns>
            <remarks>
            <para>
            You must call Run method in each request to your WebDAV server passing your 
            context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> as input parameter. 
            </para>
            </remarks>
            <example>
            <code>
            DavEngine engine = new DavEngine();
            engine.License = "...";
            ...
            MyContext context = new MyContext(HttpContext.Current);
            engine.Run(context);
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.DisposeSafe(ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            If item is not null and item implements <see cref="T:System.IDisposable"/> calls 
            <see cref="M:System.IDisposable.Dispose"/> wrapped in try-catch block.
            </summary>
            <param name="item">Item that can optionally implement <see cref="T:System.IDisposable"/>.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavEngine.ProcessWellKnownRequest(ITHit.WebDAV.Server.IHierarchyItem,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Sets 301 Moved Permanently in case of requests to '/.well-known/caldav' 
            or '/.well-known/carddav' url.
            </summary>
            <remarks>
            Gives a chance for the user to return hierarchy item that coresponds to 
            well-known requests to CalDAV and CardDAV servers.
            </remarks>
            <returns>Boolean value indicating if this is a well known request.</returns>
            <remarks>
            http://www.iana.org/assignments/well-known-uris/well-known-uris.xhtml
            http://tools.ietf.org/html/rfc5785
            http://tools.ietf.org/html/rfc6764
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.License">
            <summary>
            Gets or sets the license text.
            </summary>
            <value>
            License string
            </value>
            <remarks>
            Make sure you do not make any changes in Data and Signature tags as 
            license validation will fail in this case.
            </remarks>
            <example>
            <code>
                ...
                engine.License = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");
                ...
            </code>
            </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.CalculateContentLength">
            <summary>
            Indicates if response content length calculation will occur.
            </summary>
            <value>
            Boolean value indicating if content length will be calculated in <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> method.
            Default is <b>true</b>.
            </value>
            <remarks>
            <para>
            If this property is set to <b>true</b> engine will calculate output content length and set 
            <see cref="P:ITHit.WebDAV.Server.Extensibility.DavResponse.ContentLength"/> property before returning from <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> method.
            If you would like to send chunked responses you must set this property to <b>false</b>.
            </para>
            <para>
            ASP.NET will send chunked responses only to <b>GET</b> verb if 
            <b>HttpContext.Current.Response.BufferOutput = false</b> and request is HTTP 1.1. Responses to all
            other verbs will not be chunked.
            </para>
            <para>
            To send chunked responses from <b>HttpListener</b> you must set this property to false and set 
            <b>HttpListenerContext.Response.SendChunked = true</b>. If <b>SendChunked=false</b> and 
            <b>CalculateContentLength=false</b> than <b>HttpListener</b> will not send any response because the 
            content length will be unknown.
            </para>
            <para>
            Responses must not include both <b>Content-Length</b> header and <b>Transfer-Encoding: chunked</b> 
            header. If server is sending chunked response client application will not be able to detect content length.
            Downloading a large file using download manager client will not be able to see the entire content length 
            and evaluate time required for download.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.CorsAllowedFor">
            <summary>
            Enables or disables CORS.
            </summary>
            <remarks>
            <para>
            If this property is set to <b>*</b> CORS will be enabled for in all domains. In this case, if the <b>Origin</b> request header is available
            the Engine will extract the value of the <b>Origin</b> header and set the <b>Access-Control-Allow-Origin</b> header to the value of the <b>Origin</b> header. 
            If <b>Origin</b> header is not available the <b>Access-Control-Allow-Origin</b> header will be set to '*'.
            </para>
            <para>
            To enable CORS for a specific domain set this property to the name of the of the domain.
            To disable CORS set this property to <b>null</b> or empty string.
            </para>
            <para>
            If CORS is enabled Access-Control headers are included in all responses.
            </para>
            </remarks>
            <value>Domain for which CORS is enabled. Null or empty string if CORS is disabled. Default is <b>*</b> - CORS is enabled for all domains.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.AutoPutUnderVersionControl">
            <summary>
            Determines if placing file under version control is automatic.
            </summary>
            <remarks>
            <value>Boolean value indicating if items must be put under version control before content or properties
            update. Default is <b>true</b>.</value>
            <para>
            Determines whether items will be placed under version control automatically
            or explicit request from client shall be made to put an item under version control.
            </para>
            <para>
            If this property is <c>true</c> the <see cref="M:ITHit.WebDAV.Server.DeltaV.IVersionableItem.PutUnderVersionControl(System.Boolean)"/> will be called 
            after item is created and prior item content or properties update.
            </para>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.ContentEncoding">
            <summary>
            Gets or sets the HTTP character set of the output stream.
            </summary>
            <value>A <c>Encoding</c> object that contains information about the character set of the response.
            Default is UTF-8.</value>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.UseFullUris">
            <summary>
            Specifies whether engine shall use full or relative urls.
            </summary>
            <remarks>
            By default full urls are used.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.Logger">
            <summary>
            <see cref="T:ITHit.WebDAV.Server.ILogger"/> instance which engine will use for logging.
            </summary>
            <remarks>
            By default this is <see cref="T:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.OutputXmlFormatting">
            <summary>
            Specifies whether XML written to the output will be formatted.
            </summary>
            <remarks>
            By default XML is not formatted.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavEngine.AllowOffice12Versioning">
            <exclude />
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.FileLogger">
            <summary>
            Provides static methods for writing to a log file.
            </summary>
            <remarks>
            <para>
            By default the log file is created in the folder where the calling assembly 
            resides. You can specify the folder and file name setting <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.LogFile"/> property. 
            Amount of output and maximum file size are controlled via <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.Level"/> and <see cref="P:ITHit.WebDAV.Server.Logger.FileLogger.FileSize"/> properties.
            </para>
            <para>
            <b>Important!</b> If you host your server in IIS/ASP.NET make sure your log file is created outside of the \bin folder. If your logfile will be created in a \bin folder, your server will restart each time the logfile is updated, recycling application and session state.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.FileLogger.WriteMessage(System.String)">
            <summary>
            Wrights a message to a log file with level <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Info"/>.
            </summary>
            <param name="message">Message to be logged.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.FileLogger.WriteMessage(System.String,ITHit.WebDAV.Server.Logger.LogLevel)">
            <summary>
            Wrights a message to a log file with a specified log level.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="level">Logging level.</param>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.LogFile">
            <summary>
            Gets and sets log file name and path.
            </summary>
            <value>
            Log file name and path.
            </value>
            <remarks>
            <para>
            By default the log file is created in the folder where the calling assembly 
            resides. The folder in which you plan store your log files must exist and 
            your web application must have enough permission for writing and creating 
            files in this folder. Note that if you are creating HttpHandler-based server usually on Windows XP your web application 
            runs under ASPNET account while on Windows 2003 it runs under Network Service account.
            </para>
            <para>
            If you are requesting your server with a WebDAV client and log file is not 
            created, most likely there is no permissions for creating file or the web 
            requests simply does not reach your application.
            </para>
            <code>
            public class WebDAVHandler : IHttpHandler
            {
            	public void ProcessRequest(HttpContext context)
            	{
            		FileLogger.LogFile = context.Request.PhysicalApplicationPath + "WebDAVlog.txt";
            		...
            	}
            	...
            }
            </code>
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.Level">
            <summary>
            Gets and sets how much information is written to log file.
            </summary>
            <value>Logging level. Default is <c>Info</c></value>
            <remarks>
            Provides the method of limiting amount of logging output. During the 
            development you will usually set <c>LogLevel</c> to <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.All"/> or <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Debug"/> level, while 
            deploying you can set it to <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Error"/> or <see cref="F:ITHit.WebDAV.Server.Logger.LogLevel.Fatal"/>.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.FileSize">
            <summary>
            Gets and sets maximum log file size in bytes.
            </summary>
            <value>
            Maximum log file size in bytes. Default is 1048576 bytes.
            </value>
            <remarks>
            When the file exceeds the size specified by <c>FileSize</c> the new log file is created. The old file is renamed to &lt;filename&gt;.&lt;number&gt;.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.FileLogger.MaxBackups">
            <summary>
            Gets and sets Maximum number of log file backups.
            </summary>
            <value>
            Amount of log file backups. Default is 1.
            </value>
            <remarks>
            If the amount of the backup files created is higher than <c>MaxBackups</c> the oldest file is automatically deleted.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.FilterStreamInput">
            <summary>
            Logs input content
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.FilterStreamOutput">
            <summary>
            Calculates content length ang logs output content
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.CopyDavHandler">
            <summary>
            Summary description for CopyDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.DeleteDavHandler">
            <summary>
            Summary description for DeleteDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.GetDavHandler">
            <summary>
            Summary description for GetDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.HeadDavHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.LockDavHandler">
            <summary>
            Summary description for LockDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MkcolDavHandler">
            <summary>
            Summary description for MkcolDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.MoveDavHandler">
            <summary>
            Summary description for MoveDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.PostDavHandler">
            <summary>
            Summary description for PostDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.PropfindDavHandler">
            <summary>
            Summary description for PropfindDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.ProppatchDavHandler">
            <summary>
            Summary description for ProppatchDavHandler
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.UnlockDAVHandler">
            <summary>
            Summary description for HeadDAVHandler.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload">
            <summary>
            Implemented by a file that supports updating parts of its content.
            </summary>
            <remarks>
            <para>
            You will implement this interface together with <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress"/> interface when you would like to
            provide one or more of the following features:
            <list type="bullet">
            <item><description>Pause/resume uploads.</description></item>
            <item><description>Restore broken uploads.</description></item>
            <item><description>Upload from AJAX using POST verb and create upload progress bars. Required in IE 9 and earlier only.</description></item>
            <item><description>Upload to ASP.NET/IIS-based server files over 2Gb.</description></item>
            </list>
            </para>
            <para>The WebDAV Server Engine can process two types of upload requests:
            <list type="bullet">
            <item><description> <b>PUT upload.</b> Files uploaded via PUT by most WebDAV compliant clients.</description></item>
            <item><description> <b>POST upload.</b> Files uploaded via POST verb by Ajax applications running in Microsoft Internet Explorer 9 and earlier. </description></item>
            </list>
            </para>
            <para>To provide information about what segment of a file is being uploaded, the client application will
            attach optional <c>Content-Range: bytes XXX-XXX/XXX</c> header to PUT request. </para>
            <para>Internet Explorer 9 and earlier limitations is unable to randomly read
            file content and upload content using PUT verb. To overcome this limitation the Engine can process files
            uploaded using POST verb. 
            Internet Explorer 9 and earlier still can display upload progress submitting upload-progress REPORT request
            (see <see cref="T:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress"/> interface description for more info). </para>
            </remarks>
            <example>The following example demonstrates upload to WebDAV server using POST with multipart encoding.
            The file will be created in /mydocs/ folder.
            <code>
            <![CDATA[
            <html>
                <head><title>POST Upload to WebDAV Server</title></head>
                <body>
                    <form action="/mydocs/" method="post" enctype="multipart/form-data">
                        <input type="file" name="dummyname" /><br />
                        <input type="submit" />
                    </form>
                </body>
            </html>
            ]]>
            </code>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.CancelUpload">
            <summary>
            In this method implementation you can delete partially uploaded file.
            </summary>    
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            Often during long-continued upload you will keep the old file 
            content to be returned by GET requests and store the new file content in a
            temporary file (or temporary field in database, etc).  To delete this partially
            uploaded content client can submit CANCELUPLOAD command, the Engine will call this method in this case.
            </para>
            <para>If the item was automatically checked-out by the Engine when upload started it will be automatically
            checked-in by the Engine after this call.</para>
            </remarks>
            <example>
            Request:
            <code>
            <![CDATA[
            CANCELUPLOAD /LargeFile.doc HTTP/1.1
            Host: http://server:8580/
            ]]>
            </code>
            
            Response:
            <code>
            <![CDATA[
            HTTP/1.1 200 OK
            ]]>
            </code>
            </example>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.CancelUpload&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.LastChunkSaved">
            <summary>
            The date and time when the last chunk of file was saved in your storage.
            </summary>
            <remarks>
            <para>Requested by the Engine during a call to 
            <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress"/>.</para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.LastChunkSaved&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.BytesUploaded">
            <summary>
            Amount of bytes successfully saved to your storage.
            </summary>
            <remarks>
            <para>Client will use value returned by this property to restore broken upload.
            This value shall always reflect number of bytes already stored to persistent medium.
            </para>
            <para>Requested by the Engine during a call to 
            <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress"/>.</para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.BytesUploaded&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.ResumableUpload.IResumableUpload.TotalContentLength">
            <summary>Total file size that is being uploaded.</summary>
            <remarks>
            <para>This value is passed to <see cref="M:ITHit.WebDAV.Server.IContent.Write(System.IO.Stream,System.String,System.Int64,System.Int64)"/> method.
             Usually AJAX/HTML based clients will use value returned by this property to display upload progress.</para>
            <para>Requested by the Engine during a call to <see cref="M:ITHit.WebDAV.Server.ResumableUpload.IUploadProgress.GetUploadProgress"/>.</para>
            </remarks>
            <returns>Total file size in bytes.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IResumableUpload.TotalContentLength&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.ILock">
            <summary>
            Defines the properties and methods that WebDAV Class 2 compliant server hierarchy items must implement.
            </summary>
            <remarks>
            <para>
            This interface provides the means for locking the hierarchy item, updating lock timeout and accessing the 
            list of applied locks. To create WebDAV Class 2 compliant server you must implement this interface on 
            your file and folder items.
            </para>
            <para>
            When this interface is implemented on an item the server reports Class 2 compliance, returning DAV: 1, 2, 3 
            header in response to the OPTIONS request. Note that while most WebDAV clients never lock folder items, 
            you must still add this interface on folders, as soon as WebDAV clients submit OPTIONS request against folder 
            items when discovering server compliance.
            </para>
            <para>
            When a WebDAV client requires to protect an item from concurrent updates, it locks the item (usually file), 
            submitting lock request to server. The server generates the new lock-token, marks the item as locked and returns 
            the new lock-token to the client. The WebDAV client application keeps the lock-token and when it requires to 
            perform any updates, it supplies the lock-token with the request. When the server receives the update request, 
            it verifies that the lock token belongs to the item that is being updated and performs modifications.
            </para>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILock.GetActiveLocks">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IEnumerable`1"/> with all locks for this item.
            </summary>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            This property must return all locks for the item including deep locks on any of the parent folders.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ILock.GetActiveLocks&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILock.Lock(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.Nullable{System.TimeSpan},System.String)">
            <summary>
            Locks this item.
            </summary>
            <param name="level">Whether lock is shared or exclusive. If an exclusive lock is set other users are not 
            be able to set any locks. If a shared lock is set other users are able to set shared lock on the item.</param>
            <param name="isDeep">Specifies if the lock applied only to this item or to the entire subtree.</param>
            <param name="requestedTimeOut">Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> 
            means infinity lock that never expires. Note that your server can ignore this parameter and set 
            timeout that is different from the one requested by client. Some clients may not provide any timeout. The <b>null</b> is passed in this case.</param>
            <param name="owner">Owner of the lock as specified by client.</param> 
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Class2.LockResult"/> that contains lock-token and timeout that was actually set.
            </returns>
            <remarks>
            This method is called when item is being locked by WebDAV client. In your implementation you must do the following:
            <list type="number">
            <item><description>Generate the new lock-token, usually GUID.</description></item>
            <item><description>Save information about the lock in a storage.</description></item>
            <item><description>Associate the lock with the item in the repository.</description></item>
            <item><description>Return the lock-token to the Engine.</description></item>
            </list>
            Optionally in in this method you can modify the lock timeout requested by client. For example instead of infinity 
            lock you can set lock for some limited time. You must return both lock-token and lock timeout via <see cref="T:ITHit.WebDAV.Server.Class2.LockResult"/> 
            return value, the engine than sends the lock-token and timeout values back to WebDAV client.
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ILock.Lock&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILock.RefreshLock(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Updates lock timeout information on this item.
            </summary>
            <param name="token">Lock token.</param>
            <param name="requestedTimeOut">Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> 
            means infinity lock that never expires. Note that your server can ignore this parameter and set 
            timeout that is different from the one requested by client.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occurred during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>
            Instance of <see cref="T:ITHit.WebDAV.Server.Class2.RefreshLockResult"/> that contains information about the lock including timeout that was actually set.
            </returns>
            <remarks>This method is called when WebDAV client wants to modify (usually prolong) timeout for the previously 
            set lock. In this method implementation you can update the lock timeout. Note that you can ignore the requested 
            timout and set timeout that is different from the one requested by client.</remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ILock.RefreshLock&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.ILock.Unlock(System.String)">
            <summary>
            Removes lock with the specified token from this item.
            </summary>
            <returns>
            .
            </returns>
            <param name="lockToken">Lock with this token should be removed from the item.</param>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This folder was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.MultistatusException">Errors has occured during processing of the subtree.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <remarks>
            <para>
            If this lock included more than one hierarchy item, the lock is removed from all items included in the lock.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;ILock.Unlock&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.License.LicenseChecker">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CheckLicense(System.String)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.AddBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.DivideBigIntegers(System.Int64[],System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.MultiplyBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.SubtractBigIntegers(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.UnaryNegationBigInteger(System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.LessThanOrEqualBigInteger(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.ModulusBigInteger(System.Int64,System.Int64)">
            <exclude/>
        </member>
        <member name="M:ITHit.WebDAV.Server.License.LicenseChecker.CryptographyTest">
            <exclude/>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockInfo">
            <summary>
            Serves for exchanging locking information with WebDAV engine.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockInfo.#ctor">
            <summary>
            Initializes a new instance of the LockInfo class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockInfo.#ctor(ITHit.WebDAV.Server.Class2.LockLevel,System.Boolean,System.String,System.Nullable{System.TimeSpan},System.String,System.String)">
            <summary>
            Initializes a new instance of the LockInfo class.
            </summary>
            <param name="level">Shared or exclusive.</param>
            <param name="isDeep">Whether the lock is deep.</param>
            <param name="token">Lock token.</param>
            <param name="timeOut">Lock timeout.</param>
            <param name="owner">Lock owner.</param>
            <param name="lockRoot">Parent item on which this lock is specified explicitely.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Token">
            <summary>
            The lock token associated with a lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Level">
            <summary>
            Indicates whether a lock is shared or exclusive.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.IsDeep">
            <summary>
            Indicates whether a lock is enforceable on the subtree.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.TimeOut">
            <summary>
            Lock expiration time.
            </summary>
            <remarks>
            Lock timeout which was requested by client. <see cref="F:System.TimeSpan.MaxValue"/> means infinity
            lock that never expires. The <b>null</b> value means that timeout was not provided by a client.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.Owner">
            <summary>
            Provides information about the principal taking out a lock.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Class2.LockInfo.LockRoot">
            <summary>
            Parent item on which this lock is specified explicitely.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.LogLevel">
            <summary>
            Type of information being logged.
            </summary>
            <example>
            <code>
            FileLogger.LogFile = "C:\WebDAV\WebDAVServerLog.txt"; // C:\WebDAV\ must exist and the application must have enough permission to write and create files in this folder
            FileLogger.Level = LogLevel.Warn;
            FileLogger.WriteMessage("My error message", LogLevel.Error); // this message will be written to the log file
            FileLogger.WriteMessage("My debug message", LogLevel.Debug); // this message will not be written to the log file
            FileLogger.WriteMessage("My info message"); // this message will not be written to the log file
            </code>
            </example>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.All">
            <summary>
            All messages will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Debug">
            <summary>
            Messages with <c>LogLevel.Debug</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Info">
            <summary>
            Messages with <c>LogLevel.Info</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Warn">
            <summary>
            Messages with <c>LogLevel.Warn</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Error">
            <summary>
            Messages with <c>LogLevel.Error</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Fatal">
            <summary>
            Messages with <c>LogLevel.Fatal</c> level will be written to log.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Logger.LogLevel.Off">
            <summary>
            No messages will be written to log.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.MimeType">
             <summary>
             Provides functionality for getting mime type by file extension.
             </summary>
             <remarks>
             <para>
             The <see cref="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)"/> static method of this class returns mime type by provided file extension. 
             The class is usually utilized in <see cref="P:ITHit.WebDAV.Server.IContent.ContentType"/> implementation. The mime-type is returned in
             a Content-Type header with GET request.
             The set of values can be extended with using <see cref="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)"/> method.
             </para>
             <para>
             When deciding which action to perform when downloading a file some WebDAV clients and browsers
             (such as Internet Explorer) rely on file extension, while others (such as Firefox) rely on Content-Type header
             returned by server. For identical behavior in all browsers and WebDAV clients your server must return a correct
             mime-type with a requested file.
             </para>
             </remarks>
             <example>
             <code>
             public string ContentType
             {
                 get
                 {
                     string contentType = "";
            
                     SqlConnection conn = new SqlConnection(connStr);
                     SqlCommand cmd;
                     SqlDataReader reader = null;
                     conn.Open();
            
                     try
                     {
                         cmd = conn.CreateCommand();
                         cmd.CommandText = "SELECT ContentType FROM Repository WHERE ID = @ID";
                         cmd.Parameters.Add("@ID", SqlDbType.Int).Value = ID;
                         reader = cmd.ExecuteReader();
                         reader.Read();
                         if(!reader.IsDBNull(reader.GetOrdinal("ContentType")))
                             contentType = reader.GetString(reader.GetOrdinal("ContentType"));
                     }
                     finally
                     {
                         if(reader != null) reader.Close();
                             conn.Close();
                     }
            
                     if (string.IsNullOrEmpty(contentType))
                         contentType = 
                             MimeType.GetMimeType(System.IO.Path.GetExtension(this.fName))
                             ?? "application/octet-stream";
                     return contentType;
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.ExtendTypesTable(System.String,System.String)">
            <summary>
            Extends the list of content types or replaces existing value with a new one.
            </summary>
            <param name="extension">File extension.</param>
            <param name="mimeType">File mime type.</param>
            <example>
            <code>
            MimeType.ExtendTypesTable("exten", "application/exten");
            Console.WriteLine(MimeType.GetMimeType("exten"));
            </code>
            Writes: <c>"application/exten"</c>
            </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.MimeType.GetMimeType(System.String)">
            <summary>
            Returns the mime type corresponding to file extension.
            </summary>
            <param name="extension">File extension.</param>
            <returns>String representing mime-type or null if mime-type was not found for the specified extension.
            </returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.PropertyValue">
            <summary>
            Describes one property associated with hierarchy item object.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor(ITHit.WebDAV.Server.PropertyName)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.PropertyValue.#ctor(ITHit.WebDAV.Server.PropertyName,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="name">Property name.</param>
            <param name="value">Property value.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyValue.Value">
            <summary>
            The value of the property.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.PropertyValue.QualifiedName">
            <summary>
            Name of the property.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.ListenerRequest">
            <summary>
            Represents an incoming HTTP request for HttpListener.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Extensibility.ListenerResponse">
            <summary>
            Represents HTTP response for HttpListener.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Extensibility.ListenerResponse.response">
            <summary>
            The http response response.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Extensibility.ListenerResponse.outputStream">
            <summary>
            The output stream.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Extensibility.ListenerResponse.#ctor(System.Net.HttpListenerResponse)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.Extensibility.ListenerResponse"/> class.
            </summary>
            <param name="response">The response.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav">
            <summary>
            WebDAV constants
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.WebDav.PropertyNames">
            <summary>
            WebDAV Live Properties
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavContextBase">
             <summary>
             Serves as the abstract base class for WebDAV context.
             </summary>
             <remarks>
             <para>
             Context holds request, response and provides item factory method <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/>.
             </para>
             <para>
             When you inherit from the <c>DavContext</c> class, you must override <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> method.
             In this method you will search for file, folder, version or history item in your storage by path provided
             and return it to WebDAV engine.
             </para>
             <para>
             In each HTTP request you will create separate instance of your class derived 
             from <c>DavContext</c> with one of its overloaded constructors and pass it to <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/>.
             </para>
             <para>
             The <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> provides several overloaded constructors.
             They are optimized for use with OWIN, with IIS/ASP.NET-based server and in HttpListener-based server.
             You can also implement your own request and response classes to run the Engine in virtually any hosting environment.
             </para>
             </remarks>
             <threadsafety>Instance members of this class are not thread safe.
              You must create a separate instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class for each request.
             </threadsafety>
             <example>
             <para>HttpListener-based server:</para>
             <code>
             class Program
             {
                 static void Main(string[] args)
                 {
                     HttpListener listener = new HttpListener();
                     listener.Prefixes.Add("http://localhost:8080/");
                     listener.Start();
                     DavEngine engine = new DavEngine();
             
                     while (true)
                     {
                         HttpListenerContext context = listener.GetContext();
                         MacOsXPreprocessor.Process(context.Request); // fixes headers for Mac OS X v10.5.3 or later
            
                         if (!userAutorized(context))
                         {
                             context.Response.StatusCode = 401;
                             showLoginDialog(context, context.Response);
                             closeResponse(context);
                             continue;
                         }
            
                         context.Response.SendChunked = false;
            
                         var davContext = new MyDavContext(context, listener.Prefixes);
                         engine.Run(ntfsDavContext);
            
                         if (context.Response.StatusCode == 401)
                         {
                            showLoginDialog(context, context.Response);
                         }
            
                         closeResponse(context);
                     }
                 }
             }
             </code>
             </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(ITHit.WebDAV.Server.Extensibility.DavRequest,ITHit.WebDAV.Server.Extensibility.DavResponse)">
            <summary>
            Initializes a new instance of the WebDAV context.
            </summary>
            <param name="request"><see cref="T:ITHit.WebDAV.Server.Extensibility.DavRequest"/> implementation.</param>
            <param name="response"><see cref="T:ITHit.WebDAV.Server.Extensibility.DavResponse"/> implementation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(System.Web.HttpContext)">
            <summary>
            Initializes context for IIS/ASP.NET based server.
            </summary>
            <param name="context">An ASP.NET <c>HttpContext</c> object.</param>
            <remarks>
            <para>
            You must create a new context in each request to your WebDAV server passing ASP.NET context.
            </para>
            <para>
            This method instance is optimized for processing requests in IIS/ASP.NET-based server.
            </para>
            </remarks>
            <example>
      <para>The code below is part of 'WebDAVServer.NtfsStorage' sample provided with the SDK.</para>
      <code><![CDATA[public class DavHandler : HttpTaskAsyncHandler
{
    private readonly string license = File.ReadAllText(HttpContext.Current.Request.PhysicalApplicationPath + "License.lic");

    private static readonly bool debugLoggingEnabled =
        "true".Equals(
            ConfigurationManager.AppSettings["DebugLoggingEnabled"],
            StringComparison.InvariantCultureIgnoreCase);

    public override bool IsReusable
    {
        get { return true; }
    }
  

    public override async Task ProcessRequestAsync(HttpContext context)
    {
        DavEngineAsync engine = getOrInitializeEngine(context);

        context.Response.BufferOutput = false;
        DavContext ntfsDavContext = new DavContext(context);
        await engine.RunAsync(ntfsDavContext);
    }

    private DavEngineAsync initializeEngine(HttpContext context)
    {

        ILogger logger = Logger.Instance;
        var engine = new DavEngineAsync
        {
            Logger = logger

            // Use idented responses if debug logging is enabled.
            , OutputXmlFormatting = debugLoggingEnabled ? Formatting.Indented : Formatting.None
        };

        engine.License = license;

        return engine;
    }

    private DavEngineAsync getOrInitializeEngine(HttpContext context)
    {
        //we don't use any double check lock pattern here because nothing wrong
        //is going to happen if we created occasionally several engines.
        const string ENGINE_KEY = "$DavEngine$";
        if (context.Application[ENGINE_KEY] == null)
        {
            context.Application[ENGINE_KEY] = initializeEngine(context);
        }

        return (DavEngineAsync)context.Application[ENGINE_KEY];
    }
}
]]></code>
    </example>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.#ctor(System.Net.HttpListenerContext,System.Net.HttpListenerPrefixCollection)">
            <summary>
            Initializes context for HttpListener-based server.
            </summary>
            <param name="context">An HttpListenerContext object.</param>
            <param name="prefixes">List of HttpListener prefixes.</param>
            <remarks>
            <para>
            You must create new context in each request to your WebDAV server passing
            listener context and list of HttpListener prefixes.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;Listener.DavContextBase&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse">
            <summary>
            This method is called right before engine starts writing response.
            </summary>
            <remarks>
            <para>
            Specifically this method is called when the request is parsed, engine has
            called all methods which shall change state of an item and is ready to
            start writing response.
            </para>
            <para>
            However methods of interfaces which read data may also be called after this method.
            </para>
            <para>
            This method can be overriden to either commit or rollback transaction.
            </para>
            <para>
            In your implementation of <see cref="T:ITHit.WebDAV.Server.Extensibility.IMethodHandler"/> you need to call 
            <see cref="M:ITHit.WebDAV.Server.DavContextBase.EnsureBeforeResponseWasCalled"/>
            instead of this method to avoid double execution.
            </para>
            </remarks>
            <!-- Failed to insert some or all of included XML --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;DavContextBase.BeforeResponse&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.EnsureBeforeResponseWasCalled">
            <summary>
            Calls <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> only first time this method is invoked.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.LocalizeSatus(ITHit.WebDAV.Server.DavStatus)">
            <summary>
            May be overriden to localize HTTP status message.
            </summary>
            <param name="status">Status to be localized.</param>
            <returns>Localized status which will be written to the response.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)">
            <summary>
            Implementation of this abstract method is used by WebDAV engine to find hierarchy item objects by path.
            </summary>
            <param name="path">
            Path of the hierarchy item object.
            It is always the full path from the root of the WebDAV repository.
            </param>
            <returns>
            Hierarchy item object referenced by the specified path or <c>null</c>
            if hierarchy item not found.
            </returns>
            <remarks>
            <para>
            When you inherit from the <c>DavContext</c> class, you must override this abstract method.
            For WebDAV Class 1 and Class 2 server in this method implementation you will search for file or folder in
            your storage by path provided and return it to WebDAV engine. 
            For DeltaV server in addition to folder or file item you will return version and history items.
            </para>
            </remarks>
            <!-- No matching elements were found for the following include tag --><include file="Comments\Generated.xml" path="doc/example[@name=&quot;DavContextBase.GetHierarchyItem&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Exception">
            <summary>
            Exception which occurred during request execution.
            </summary>
            <remarks>
            <para>
            This can be either exception raised by your implementation or exception
            raised be engine internally. In your <see cref="M:ITHit.WebDAV.Server.DavContextBase.BeforeResponse"/> implementation you will use it to see 
            if processing was successful or not and to commit or rollback a transaction.
            </para>
            <para>
            This exception will be sent to client.
            </para>
            </remarks>
            <!-- Failed to insert some or all of included XML --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;DavContextBase.BeforeResponse&quot;]/*"/>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Request">
            <summary>
            Object representing current request.
            </summary>
            <remarks>
            This may not be necesserily the request that was passed to the constructor because
            engine may wraps the request and response.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Response">
            <summary>
            Object representing current response.
            </summary>
            <remarks>
            This may not be necesserily the response that was passed to the constructor because
            engine may wrap the request and response.
            </remarks>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavContextBase.Engine">
            <summary>
            Instance of DavEngine which is currently executing the request.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Search.SearchOptions">
            <summary>
            Represents DASL search parameters.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Search.SearchOptions.SearchContent">
            <summary>
            Gets the value indicating that the search is performed in a file content.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Search.SearchOptions.SearchName">
            <summary>
            Gets the value indicating that the search is performed in a file name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Acl.MatchBy">
            <summary>
            Is used by <see cref="M:ITHit.WebDAV.Server.Acl.IAclHierarchyItem.GetItemsByProperty(ITHit.WebDAV.Server.Acl.MatchBy,System.Collections.Generic.IList{ITHit.WebDAV.Server.PropertyName})"/> to identify by which
            property items shall be retrieved.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.MatchBy.Group">
            <summary>
            This value is used to indicate that items whose Group contains currently
            logged in principal shall be returned.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Acl.MatchBy.Owner">
            <summary>
            This value is used to indicate that items whose Owner corresponds
            to or contains currently logged in principal shall be returned.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Class2.LockedException">
            <summary>
            This exception shall be thrown in cases when item is locked and client didn't provide lock token or if the item is already locked.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Class2.LockedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the LockedException class.
            </summary>
            <param name="info">Serialization info.</param>
            <param name="context">Context.</param>
        </member>
        <member name="T:ITHit.WebDAV.Server.DavStatus">
            <summary>
            Represents HTTP status code with description.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.OK">
            <summary>
            Successful result.
            </summary>  
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.UNAUTHORIZED">
            <summary>
            The request requires user authentication.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.CONFLICT">
            <summary>
            The request could not be completed due to a conflict with the current state of the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.CREATED">
            <summary>
            The request has been fulfilled and resulted in a new resource being created.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FAILED_DEPENDENCY">
            <summary>
            This status code means that the method could
            not be performed on the resource because the requested action
            depended on another action and that action failed.  For example, if a
            command in a PROPPATCH method fails, then, at minimum, the rest of
            the commands will also fail with 424 (Failed Dependency).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.LOCKED">
            <summary>
            This status code means the source or destination resource
            of a method is locked.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NO_CONTENT">
            <summary>
            The server has fulfilled the request but does not need to return an entity-body, and might want to return
            updated metainformation.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_ALLOWED">
            <summary>
            The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.PRECONDITION_FAILED">
            <summary>
            The precondition given in one or more of the request-header fields evaluated to false when it was tested on
            the server.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.INTERNAL_ERROR">
            <summary>
            The server encountered an unexpected condition which prevented it from fulfilling the request. 
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.BAD_REQUEST">
            <summary>
            The request could not be understood by the server due to malformed syntax.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.MULTISTATUS">
            <summary>
            The 207 (Multi-Status) status code provides status for multiple
            independent operations.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_FOUND">
            <summary>
            The server has not found anything matching the Request-URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_MODIFIED">
            <summary>
            If the client has performed a conditional GET request and access is allowed, but the document has not been
            modified, the server SHOULD respond with this status code.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.PARTIAL_CONTENT">
            <summary>
            The server has fulfilled the partial GET request for the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FORBIDDEN">
            <summary>
            The server understood the request, but is refusing to fulfill it.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.NOT_IMPLEMENTED">
            <summary>
            The server does not support the functionality required to fulfill the request. This is the appropriate 
            response when the server does not recognize the request method and is not capable of supporting it for any
            resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.UNSUPPORTED_MEDIA_TYPE">
            <summary>
            The server is refusing to service the request because the entity of the request is in a format not
            supported by the requested resource for the requested method. 
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.MOVED_PERMANENTLY">
            <summary>
            The requested resource resides permanently under a different URI.
            </summary>
            <remarks>The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise.</remarks>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.FOUND">
            <summary>
            The requested resource resides temporarily under a different URI.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.DavStatus.INSUFFICIENT_STORAGE">
            <summary>
            The 507 (Insufficient Storage) status code means the method could not
            be performed on the resource because the server is unable to store
            the representation needed to successfully complete the request.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.#ctor(System.Int32,System.String)">
            <summary>
            Initializes a new instance of the DavStatus struct.
            </summary>
            <param name="code">HTTP status code.</param>
            <param name="description">Status description.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.Equals(ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.op_Equality(ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if two objects are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.op_Inequality(ITHit.WebDAV.Server.DavStatus,ITHit.WebDAV.Server.DavStatus)">
            <summary>
            Unequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if two objects are not equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.DavStatus.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.Code">
            <summary>
            HTTP status code.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.Description">
            <summary>
            Status description.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.DavStatus.HttpString">
            <summary>
            Formats status as HTTP string.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.EncodeUtil">
            <summary>
            Encodes/Decodes url parts.
            </summary>
            <remarks>
            This class shall be used to encode/decode parts of urls. Unlike <see cref="T:System.Web.HttpUtility"/> class provided with .Net, this class encodes ' '(space) as %2b.
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.EncodeUtil.EncodeUrlPart(System.String)">
            <summary>
            Encodes url part.
            </summary>
            <param name="part">Url part to encode.</param>
            <returns>Encoded url part.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.EncodeUtil.DecodeUrlPart(System.String)">
            <summary>
            Decodes url part.
            </summary>
            <param name="part">Url part to decode.</param>
            <returns>Decoded url part.</returns>
        </member>
        <member name="T:ITHit.WebDAV.Server.ErrorDetails">
            <summary>
            Describes detail that can be passed to <see cref="T:ITHit.WebDAV.Server.DavException"/>.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_IN">
            <summary>
            If a version-controlled resource is being checked out, it MUST have a DAV:checked-in property
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_OUT">
            <summary>
            If a version-controlled resource is being checked out, it MUST have a DAV:checked-out property
            </summary>        
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_RENAME_HISTORY">
            <summary>
            If the request-URL identifies a version history, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_COPY_HISTORY">
            <summary>
            If the request-URL identifies a version
            history, the request MUST fail. In order to create another
            version history whose versions have the same content and dead
            properties, the appropriate sequence of VERSION-CONTROL, CHECKOUT,
            PUT, PROPPATCH, and CHECKIN requests must be made
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.MUST_BE_CHECKED_OUT_VERSION_CONTROLLED_RESOURCE">
            <summary>
            The request-URL MUST identify a version-controlled resource with a DAV:checked-out property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.VERSION_HISTORY_IS_TREE">
            <summary>
            If the request-URL identifies a
            checked-out version-controlled resource that will be automatically
            checked in when the lock is removed, then the versions identified
            by the DAV:predecessor-set of the checked-out resource MUST be
            descendants of the root version of the version history for the
            DAV:checked-out version.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION_CONTROLLED_CONTENT">
            <summary>
            If the request-URL
            identifies a resource with a DAV:checked-in property, the request
            MUST fail unless DAV:auto-version semantics will automatically
            check out the resource.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION_CONTROLLED_PROPERTY">
            <summary>
            If the request attempts to modify a dead property, same semantics as PUT
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.SUPPORTED_LIVE_PROPERTY">
            <summary>
            If the request attempts to access a
            property defined by this document, the semantics of that property
            MUST be supported by the server.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_VERSION">
            <summary>
            If the request-URL identifies a version, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_RENAME_VERSION">
            <summary>
            If the request-URL identifies a version, the request MUST fail.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_VERSION_DELETE">
            <summary>
            A server MAY fail an attempt to DELETE a version.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.SUPPORTED_REPORT">
            <summary>
            The specified report MUST be supported by
            the resource identified by the request-URL.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.CANNOT_MODIFY_PROTECTED_PROPERTY">
            <summary>
            The client attempted to set a protected property in a PROPPATCH (such as DAV:getetag).
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.PROPFIND_FINITE_DEPTH">
            <summary>
            This server does not allow infinite-depth PROPFIND requests on collections.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.PRESERVED_LIVE_PROPERTIES">
            <summary>
            The server received an otherwise-valid MOVE or COPY request, but
            cannot maintain the live properties with the same behavior at the destination. It may be that
            the server only supports some live properties in some parts of the repository, or simply has an
            internal error.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_CONFLICTING_LOCK">
            <summary>
            A LOCK request failed due the presence of an already existing conflicting lock. Note that a
            lock can be in conflict although the resource to which the request was directed is only
            indirectly locked. In this case, the precondition code can be used to inform the client about
            the resource that is the root of the conflicting lock, avoiding a separate lookup of the
            "lockdiscovery" property.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.LOCK_TOKEN_SUBMITTED">
            <summary>
            The request could not succeed because a lock token should have been submitted. This
            element, if present, MUST contain at least one URL of a locked resource that prevented the
            request. In cases of MOVE, COPY, and DELETE where collection locks are involved, it can
            be difficult for the client to find out which locked resource made the request fail -- but the
            server is only responsible for returning one such locked resource. The server MAY return
            every locked resource that prevented the request from succeeding if it knows them all.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.LOCK_TOKEN_MATCHES_REQUEST_URI">
            <summary>
            A request may include a Lock-Token header to identify a lock for the
            UNLOCK method. However, if the Request-URI does not fall within the scope of the lock
            identified by the token, the server SHOULD use this error. The lock may have a scope that
            does not include the Request-URI, or the lock could have disappeared, or the token may be
            invalid.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NO_EXTERNAL_ENTITIES">
            <summary>
            If the server rejects a client request because the request body contains an
            external entity, the server SHOULD use this error.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.ErrorDetails.NUMBER_OF_MATCHES_WITHIN_LIMITS">
            <summary>
            The number of matching principals must fall within
            server-specific, predefined limits. For example, this condition might be triggered if a search specification
            would cause the return of an extremely large number of responses.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the ErrorDetails struct.
            </summary>
            <param name="namespace">Element namespace.</param>
            <param name="name">Element name.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.Equals(ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.op_Equality(ITHit.WebDAV.Server.ErrorDetails,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Equality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if items are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.op_Inequality(ITHit.WebDAV.Server.ErrorDetails,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Inequality operator.
            </summary>
            <param name="left">Left operand.</param>
            <param name="right">Right operand.</param>
            <returns><c>true</c> if items are equal.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise,
            false.
            </returns>
            <param name="obj">Another object to compare to.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:ITHit.WebDAV.Server.ErrorDetails.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:ITHit.WebDAV.Server.ErrorDetails.Namespace">
            <summary>
            Gets element namespace.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.ErrorDetails.Name">
            <summary>
            Gets element name.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.ILogger">
            <summary>
            Engine uses this interface to perform logging.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILogger.LogDebug(System.String)">
            <summary>
            Logs message in debug mode.
            </summary>
            <param name="message">Message to be logged.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.ILogger.LogError(System.String,System.Exception)">
            <summary>
            Logs message in error mode.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="exception">Exception to be logged.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.ILogger.IsDebugEnabled">
            <summary>
            Determines whether debug mode is enabled.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.ILogger.LogFlags">
            <summary>
            Logging flags.
            </summary>
            <remarks>By default Engine does not log GET response body and PUT request body.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl">
            <summary>
            Default logger implementation.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogDebug(System.String)">
            <summary>
            Logs in debug mode.
            </summary>
            <param name="message">Message.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogError(System.String,System.Exception)">
            <summary>
            Logs message in error mode.
            </summary>
            <param name="message">Message to be logged.</param>
            <param name="exception">Exception to be logged.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogFile">
            <summary>
            Log file path.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.IsDebugEnabled">
            <summary>
            Determines whether debug mode is enabled.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Logger.DefaultLoggerImpl.LogFlags">
            <summary>
            Logging flags.
            </summary>
            <remarks>By default Engine does not log GET response body and PUT request body.</remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase">
            <summary>
            Base class for responses to be included into multistatus response.
            Basically it can be either <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse"/> or <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="itemPath">Path to the item.</param>
            <param name="responseDescription">Description of the response.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.ItemPath">
            <summary>
            Path of an item this response relates to.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ResponseBase.ResponseDescription">
            <summary>
            Description of the response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse">
            Status for an items to be included into multistatus response. 
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.#ctor(System.String,ITHit.WebDAV.Server.DavStatus,System.String,System.String)">
             Initializes a new instance.
            
             @param itemPath Path of the item in the hierarchy tree.
             @param status WebDAV response for the item.
             @param href href to be included in the response.
             @param responseDescription description of the response.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.Hrefs">
             Hrefs included in the response.
            
             @return path of the item.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse.Code">
             Gets the response for the item.
            
             @return response for the item
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.MultistatusResponse.AddResponse(System.String,ITHit.WebDAV.Server.DavStatus,System.String,System.String)">
            <summary>
            Adds new responses to the private collection in this class.
            </summary>
            <param name="path"></param>
            <param name="code"></param>
            <param name="href"></param>
            <param name="responseDescription"></param>   
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStat">
            Status for a number of properties to be included into multistatus response. 
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.PropStat.#ctor(System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.PropertyValue},ITHit.WebDAV.Server.DavException)">
            Initializes new instance.
            @param property list of properties with the same status.
            @param status status for these properties.
            @param description description.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.PropStat.Properties">
            Retrieves list of properties with the same status.
            @return list of properties.
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse">
            Response that may be present in multistatus response.
            Describes status of properties relating to the same item.
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse.#ctor(System.String,System.Collections.Generic.IEnumerable{ITHit.WebDAV.Server.Impl.Multistatus.PropStat},System.String)">
             Initializes new instance.
            
             @param itemPath    path to item which contains these properties.
             @param propStats   statuses for different properties related to this item.
             @param description description for the response.
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse.PropStats">
             Retrieves statuses for properties grouped by item they relate to.
            
             @return statuses for properties.
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.Multistatus.Response">
            <summary>
            Base class for responses to be included into multistatus response.
            Basically it can be either <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.PropStatResponse"/> or <see cref="T:ITHit.WebDAV.Server.Impl.Multistatus.ItemResponse"/>.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.Multistatus.Response.#ctor(System.String,System.String)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="itemPath">Path to the item.</param>
            <param name="responseDescription">Description of the response.</param>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.Response.ItemPath">
            <summary>
            Path of an item this response relates to.
            </summary>
        </member>
        <member name="P:ITHit.WebDAV.Server.Impl.Multistatus.Response.ResponseDescription">
            <summary>
            Description of the response.
            </summary>
        </member>
        <member name="T:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler">
            <summary>
            Summary description for AclDAVHandler.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler.AppliesTo(ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Determines whether this method shall be enlisted in 'supported-method-set' for 
            <paramref name="item"/>.
            </summary>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> or <b>null</b>.</param>
            <returns>Boolean indicating whether this handler implementation can handle request for the item.</returns>
        </member>
        <member name="M:ITHit.WebDAV.Server.Impl.MethodHandlers.AclDAVHandler.ProcessRequest(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem)">
            <summary>
            Processes request.
            </summary>
            <param name="context">Instance of context class derived from <see cref="T:ITHit.WebDAV.Server.DavContextBase"/> class.</param>
            <param name="item">Hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> or <b>null</b>.</param>
            <remarks>The <see cref="M:ITHit.WebDAV.Server.Extensibility.IMethodHandler.ProcessRequest(ITHit.WebDAV.Server.DavContextBase,ITHit.WebDAV.Server.IHierarchyItem)"/> method is called by the engine during <see cref="M:ITHit.WebDAV.Server.DavEngine.Run(ITHit.WebDAV.Server.DavContextBase)"/> call. 
            The hierarchy item returned from <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> is passed to this method. 
            If <see cref="M:ITHit.WebDAV.Server.DavContextBase.GetHierarchyItem(System.String)"/> returns null the null is passed.
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItem">
            <summary>
            Implement this interface if your repository will be viewed by Windows Explorer,
            so it is possible to view/modify attributes of files/folders.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItem.GetFileAttributes">
            <summary>
            Retrieves file attributes.
            </summary>
            <returns>File attributes.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IMsItem.GetFileAttributes&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.MicrosoftExtensions.IMsItem.SetFileAttributes(System.IO.FileAttributes)">
            <summary>
            Updates file attributes.
            </summary>
            <param name="value">File attributes.</param>
            <returns>
            .
            </returns>
            <exception cref="T:ITHit.WebDAV.Server.Class2.LockedException">This item was locked. Client did not provide the lock token.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">Quota limit is reached.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IMsItem.SetFileAttributes&quot;]/*"/>
        </member>
        <member name="T:ITHit.WebDAV.Server.MultistatusException">
            <summary>
            Exception which contains errors for multiple items or properties.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor(System.String)">
            <summary>
            Initializes new message.
            </summary>
            <param name="message">Error text.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:ITHit.WebDAV.Server.DavException"/> class with serialized data. 
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the
            exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the
            source or destination. </param>
            <exception cref="T:System.ArgumentNullException">The info parameter is null.</exception>
            <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or HResult is zero (0).</exception>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(ITHit.WebDAV.Server.MultistatusException)">
            <summary>
            Adds all errors from <paramref name="mex"/> exception to this one.
            </summary>
            <param name="mex">Exception to merge with.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.DavException)">
            <summary>
            Adds item error.
            </summary>
            <param name="itemPath">tem path for which operation failed.</param>
            <param name="exception">Exception for failed operation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.AddInnerException(System.String,ITHit.WebDAV.Server.PropertyName,ITHit.WebDAV.Server.DavException)">
            <summary>
            Addes property error.
            </summary>
            <param name="itemPath">Item path for which property operation failed.</param>
            <param name="propertyName">Property name for which operation failed.</param>
            <param name="exception">Exception for failed operation.</param>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.Render(ITHit.WebDAV.Server.DavContextBase,System.Boolean)">
            <summary>
            Writes exception to the output writer.
            </summary>        
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>
            <param name="renderContent">Whether content shall be written to output.</param>
            <remarks>        
            Full response shall be formed, including HTTP status and headers.
            <code>
            <![CDATA[
                HTTP/1.1 409 Conflict
                Content-Type: text/xml; charset="utf-8"
                Content-Length: 97
            
                <?xml version="1.0" encoding="utf-8" ?>
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                   <D:responsedescription>Item must be checked out.</D:responsedescription>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="M:ITHit.WebDAV.Server.MultistatusException.RenderInline(System.Xml.XmlWriter,ITHit.WebDAV.Server.DavContextBase)">
            <summary>
            Writes exception as part of MultistatusException.
            </summary>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to which to write exception.</param>
            <param name="context">Instance of <see cref="T:ITHit.WebDAV.Server.DavContextBase"/>.</param>        
            <remarks>        
            Only body shall be written. Text in <see cref="P:System.Exception.Message"/>
            shall be omitted because it will be written as part of <see cref="T:ITHit.WebDAV.Server.MultistatusException"/> exception.
            <code>
            <![CDATA[
                <D:error xmlns:D="DAV:">
                   <D:must-be-checked-out/>
                </D:error>
            ]]>
            </code>
            </remarks>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.InsufficientStorageException">
            <summary>
            Shall be thrown if quota limits are exceeded or there is no physical space left.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Quota.InsufficientStorageException.QUOTA_NOT_EXCEEDED">
            <summary>
            Quota was exceeded.
            </summary>
        </member>
        <member name="F:ITHit.WebDAV.Server.Quota.InsufficientStorageException.SUFFICIENT_DISK_SPACE">
            <summary>
            There is insufficient physical space to execute the request.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.InsufficientStorageException.#ctor">
            <summary>
            Initializes new instance.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.InsufficientStorageException.#ctor(System.String,ITHit.WebDAV.Server.ErrorDetails)">
            <summary>
            Initializes new instance.
            </summary>
            <param name="message">Error message.</param>
            <param name="reason">One of </param>
        </member>
        <member name="T:ITHit.WebDAV.Server.Quota.IQuota">
            <summary>
            If your server implementation needs to support quotas, this interface must be
            implemented by collections (items which implement <see cref="T:ITHit.WebDAV.Server.Class1.IFolder"/>, <see cref="T:ITHit.WebDAV.Server.Acl.IPrincipalFolder"/> etc.
            interfaces).
            Optionally this interface can be implemented by other items depending on your requirements.
            </summary>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.IQuota.GetAvailableBytes">
            <summary>
            Value in bytes representing the amount of additional disk space beyond the current
            allocation that can be allocated to the folder (or other item) before further
            allocations will be refused.
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>Bytes that can be additionally allocated in folder/file.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IQuota.GetAvailableBytes&quot;]/*"/>
        </member>
        <member name="M:ITHit.WebDAV.Server.Quota.IQuota.GetUsedBytes">
            <summary>
             Value in bytes representing the amount of space used by this folder/file
             and possibly a number of other similar folders/files, where the set of "similar" meets at least
             the criterion that allocating space to any folder/file in the set will
             count against the <see cref="M:ITHit.WebDAV.Server.Quota.IQuota.GetAvailableBytes"/>. It MUST include the
             total count including usage derived from sub-items if
             appropriate. It SHOULD include metadata storage size if metadata
             storage is counted against the <see cref="M:ITHit.WebDAV.Server.Quota.IQuota.GetAvailableBytes"/>
            </summary>
            <exception cref="T:ITHit.WebDAV.Server.Acl.NeedPrivilegesException">The user doesn't have enough privileges.</exception>
            <exception cref="T:ITHit.WebDAV.Server.DavException">In other cases.</exception>
            <returns>Bytes occupied by folder/file.</returns>
            <!-- No matching elements were found for the following include tag --><include file="..\Comments\Generated.xml" path="doc/example[@name=&quot;IQuota.GetUsedBytes&quot;]/*"/>
        </member>
    </members>
</doc>
